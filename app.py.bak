# =================================================================
# BLOQUE 1: IMPORTACIONES (Librerías y Módulos)
# =================================================================

# 1.1. Librerías Estándar de Python
import io
import os
import re
import unicodedata
import calendar
from io import BytesIO
from collections import defaultdict
from datetime import datetime, date, timedelta, timezone
from urllib.parse import quote,urlencode, urlparse, parse_qs

# 1.2. Librerías de Terceros (Flask, Mongo, Utilidades)
from flask import (
    Flask, render_template, request, redirect,
    url_for, jsonify, abort, send_file, flash
)
from flask_pymongo import PyMongo
from bson import ObjectId
from dateutil.relativedelta import relativedelta

# 1.3. Manejo de Importaciones Opcionales o Condicionales
try:
    from openpyxl import Workbook
except Exception:
    Workbook = None

# Blueprint de Salidas
try:
    from salidas_blueprint import salidas_bp
except ImportError:
    # Definición dummy si el blueprint no existe para evitar errores de importación 
    class DummyBlueprint:
        def register(self, app, url_prefix=None):
            pass
    salidas_bp = DummyBlueprint()

# Sistema de Notificaciones (Email)
try:
    from notify import send_email 
except ImportError:
    def send_email(*args, **kwargs):
        print("WARN: Función send_email no disponible. No se enviará email.")

# =================================================================
# BLOQUE 2: CONFIGURACIÓN DE APP, MONGO Y BLUEPRINTS
# =================================================================

app = Flask(__name__)

app.secret_key = os.environ.get("SECRET_KEY", "EP91_super_secret_2025_cambiar_en_prod")

# Configuración de base de datos
MONGO_URI = "mongodb+srv://ep91_user:NsbxKq65WWOm9lQB@cluster0.o7ctg8u.mongodb.net/ep91_db?retryWrites=true&w=majority&appName=Cluster0"
app.config["MONGO_URI"] = MONGO_URI

# Inicialización de PyMongo (Instancia Única)
mongo = PyMongo(app)

# Exponer la base de datos para que sea accesible desde Blueprints
app.mongo = mongo.db

# Registro de rutas modulares (Blueprints)

app.register_blueprint(salidas_bp, url_prefix="/salidas")

# ----------------- Collections -----------------
COL_DOCENTES        = mongo.db.docentes
COL_AUX             = mongo.db.auxiliares
COL_ALUMNOS         = mongo.db.alumnos
COL_MOVIMIENTOS     = mongo.db.movimientos_alumnos
COL_INASISTENCIAS_DOCENTES   = mongo.db.inasistencias
COL_ASISTENCIAS     = mongo.db.asistencias
COL_ASISTENCIA      = mongo.db.asistencias   # alias para compatibilidad con código que usa COL_ASISTENCIA
COL_DIAS_HABILES    = mongo.db.dias_habiles  # colección para almacenar días hábiles por curso/mes
COL_INASISTENCIAS     = mongo.db.inasistencias
COL_ESTADOS_ADMIN   = mongo.db.estados_admin
COL_CALIFICACIONES  = mongo.db.calificaciones
COL_CFG_ASIGNATURAS = mongo.db.config_asignaturas
COL_CURSOS          = mongo.db.cursos  # Agregado para evitar error de definición
COL_CONFIG          = mongo.db.config   # Colección para configuraciones generales (ej. _id: "config_general")COL_CERTIFICADOS    = mongo.db["certificados_pendientes"]
COL_CERTIFICADOS    = mongo.db.certificados_pendientes
COL_CALENDARIO_ESCOLAR = mongo.db.calendario_escolar
COL_MERCADERIA      = mongo.db.entrega_mercaderia
COL_INASISTENCIAS_AUX = mongo.db.inasistencias_auxiliares


# ----------------- Authentication Placeholder ----------------- 

# Función de ejemplo para obtener el usuario actual (placeholder) 
def get_current_user():
    """Placeholder para obtener la información del usuario actual (admin, director, docente)"""
    # En un entorno real, esto se obtendría de la sesión o token
    # Para la simulación, retornamos un usuario predefinido
    return {
        "uid": "simulated_admin_user",
        "rol": "admin", # Puede ser 'admin', 'director', 'docente' 
        "nombre": "Admin Demo",
        "docente_id": None # Si el rol es 'docente', aquí iría su ObjectId
    }
# ----------------- CONFIG CALIFICACIONES -----------------
# Asignaturas por ciclo / grado (puedes ajustar nombres cuando quieras)

CFG_ASIGNATURAS = {
    "1": [
        "Prácticas del Lenguaje",
        "Matemática",
        "Ciencias Sociales",
        "Ciencias Naturales",
        "Educación Física",
        "Educación Artística"
    ],
    "2": [
        "Prácticas del Lenguaje",
        "Matemática",
        "Ciencias Sociales",
        "Ciencias Naturales",
        "Educación Física",
        "Educación Artística"
    ],
    "3": [
        "Prácticas del Lenguaje",
        "Matemática",
        "Ciencias Sociales",
        "Ciencias Naturales",
        "Educación Física",
        "Educación Artística"
    ],
    "4": [
        "Prácticas del Lenguaje",
        "Matemática",
        "Ciencias Sociales",
        "Ciencias Naturales",
        "Inglés",
        "Educación Física",
        "Educación Artística"
    ],
    "5": [
        "Prácticas del Lenguaje",
        "Matemática",
        "Ciencias Sociales",
        "Ciencias Naturales",
        "Inglés",
        "Educación Física",
        "Educación Artística"
    ],
    "6": [
        "Prácticas del Lenguaje",
        "Matemática",
        "Ciencias Sociales",
        "Ciencias Naturales",
        "Inglés",
        "Educación Física",
        "Educación Artística" 
    ]
}

def _get_cfg_calificaciones():
    """
    Retorna la configuración de asignaturas por ciclo/grado.
    Función simple para mantener compatibilidad con llamadas en la app;
    si en el futuro se requiere enriquecerla (p. ej. fusionar con
    COL_CFG_ASIGNATURAS de la DB), puede ampliarse aquí. 
    """
    return CFG_ASIGNATURAS

def filtro_activos():
    return {"$or": [
        {"fecha_salida": {"$exists": False}},  
        {"fecha_salida": ""},
        {"fecha_salida": None},
    ]}


def _insert_movimiento_si_no_duplicado(doc, segundos=5): 
    """
    Evita duplicados si el form se envía 2 veces.
    Considera duplicado: mismo alumno_id + tipo + campos clave dentro de los últimos X segundos.
    """
    try:
        desde = datetime.utcnow() - timedelta(seconds=segundos)

        q = {
            "alumno_id": doc.get("alumno_id"),
            "tipo": doc.get("tipo"),
            "fecha": {"$gte": desde},
        } 

        # Campos opcionales que hacen “único” al movimiento
        for k in ("curso_origen", "curso_destino", "curso", "motivo", "escuela_destino"):
            v = doc.get(k)
            if v not in (None, ""):
                q[k] = v

        # Si ya existe uno igual recientemente, no insertamos
        if COL_MOVIMIENTOS.find_one(q):
            return False

        COL_MOVIMIENTOS.insert_one(doc)
        return True

    except Exception as e:
        print("Error en _insert_movimiento_si_no_duplicado:", e)
        # ante duda, insertamos igual para no “perder” el movimiento
        try:
            COL_MOVIMIENTOS.insert_one(doc)
        except Exception:
            pass
        return True
  
# ----------------- Helpers genéricos -----------------

def to_json(doc):
    d = dict(doc)
    d["_id"] = str(d["_id"])
    return d

def mongo_ping_ok(timeout_ms=1000):
    """Devuelve True si MongoDB responde al ping, False en caso contrario."""
    try:
        # Flask-PyMongo expone el cliente en distintos atributos según versión
        client = getattr(mongo, "cx", None) or getattr(mongo, "mongo_client", None) or getattr(mongo, "client", None)
        if not client:
            return False
        # comando ping simple
        client.admin.command("ping")
        return True
    except Exception:
        return False

def matriz_5x5_vacia():
    return [["" for _ in range(5)] for _ in range(5)] 

def calcular_edad(fecha_nacimiento, referencia=None):
    if not fecha_nacimiento: 
        return None
    if isinstance(fecha_nacimiento, str):
        try:
            fecha_nacimiento = datetime.strptime(fecha_nacimiento, "%Y-%m-%d").date()
        except:
            return None
    referencia = referencia or date(datetime.now().year, 6, 30)  # 30/06 año actual
    return relativedelta(referencia, fecha_nacimiento).years

def today():
    # Devuelve la fecha actual como date (útil para comparaciones y strftime)
    return date.today()

def today_datetime():
    """Retorna la fecha y hora actual con info de zona horaria (UTC)"""
    return datetime.now(timezone.utc)


def datetimeformat(value, format='%Y-%m-%d'):
    if isinstance(value, datetime) or isinstance(value, date):
        return value.strftime(format)
    return value


def parse_curso(curso_str: str):
    """
    Convierte '1°A' -> (1, 'A') | '3°B' -> (3, 'B')
    Devuelve (None, None) si no matchea.
    """
    if not curso_str:
        return None, None
    s = curso_str.strip().upper().replace(" ", "")
    m = re.match(r"^([1-6])°([AB])$", s)
    if not m:
        return None, None
    return int(m.group(1)), m.group(2)

def build_curso(grado: int, seccion: str):
    return f"{grado}°{seccion.upper()}"

# Registrar filtro Jinja tras definir la función
app.jinja_env.filters['strftime'] = datetimeformat
  

def dias_restantes(f_limite_str):
    if not f_limite_str: 
        return None
    try:
        f = datetime.strptime(f_limite_str[:10], "%Y-%m-%d").date()
    except Exception:
        return None
    try:
        return (f - today()).days
    except Exception:
        return None
MESES_MAYUS = {
    1: "ENERO", 2: "FEBRERO", 3: "MARZO", 4: "ABRIL",
    5: "MAYO", 6: "JUNIO", 7: "JULIO", 8: "AGOSTO",
    9: "SEPTIEMBRE", 10: "OCTUBRE", 11: "NOVIEMBRE", 12: "DICIEMBRE"
}

def fecha_larga_castellano(fecha):
    if isinstance(fecha, str):
        fecha = datetime.strptime(fecha, "%Y-%m-%d").date()
    return f"{fecha.day} días de {MESES_MAYUS[fecha.month]} del año {fecha.year}"

LEG_CAMPOS = [
    ("dni_menor", "Fotocopia DNI alumno/a"),
    ("partida_nacimiento", "Partida de nacimiento"),
    ("vacunas_calendario", "Vacunas de calendario"),
    ("vacunas_covid", "Vacunas COVID"),
    ("dni_responsables", "DNI madre/padre/tutor"),
    ("dni_autorizados", "DNI de autorizados a retirar"),
]


def _split_cargos(docente):
    cargo_raw = (docente.get("cargo") or "").strip()
    return [c.strip().upper() for c in cargo_raw.split(",") if c.strip()]

def docente_concurre_todos_los_dias(docente):
    """
    True si concurre L-V.
    Regla: SOLO si el cargo es PROFESOR como único cargo => variable.
    PROFESOR + otro cargo => se considera que concurre todos los días.
    """
    cargos = _split_cargos(docente)
    return cargos != ["PROFESOR"]

def dias_semana_con_horas_docente(docente):
    """
    Devuelve set() de weekdays (0-4) donde tiene al menos una hora en la matriz 5x5.
    0=Lun ... 4=Vie
    """
    matriz = docente.get("carga_horaria") or []
    dias = set()

    for r in range(5):      # horas
        for c in range(5):  # días
           
            try:
                val = matriz[r][c]
            except Exception:
                val = ""
            if isinstance(val, str) and val.strip():
                dias.add(c)

    return dias

            # --------- Helpers Inasistencias (normalización y topes) ----------

def _normalizar_texto(txt: str) -> str:
    if not txt:
        return ""
    txt = txt.strip().lower()
    txt = unicodedata.normalize("NFD", txt)
    txt = "".join(c for c in txt if unicodedata.category(c) != "Mn")
    txt = re.sub(r"\s+", " ", txt).strip()
    return txt

def _norm(s: str) -> str:
    return _normalizar_texto(s)

def _parse_date(valor):
    if isinstance(valor, date):
        return valor
    if not valor:
        return None
    s = str(valor).strip()
    for fmt in ("%Y-%m-%d", "%d/%m/%Y"):
        try:
            return datetime.strptime(s, fmt).date()
        except ValueError:
            continue
    return None

def _year_bounds(d):
    base = d or date.today()
    return date(base.year, 1, 1), date(base.year, 12, 31)

def _maybe_oid(x):
    if isinstance(x, ObjectId):
        return x
    try:
        return ObjectId(str(x))
    except Exception:
        return str(x)

def _is_preexamen(causa_norm: str) -> bool:
    c = causa_norm
    return ("pre" in c) and ("examen" in c)

def _es_citacion_otro_est(c_norm: str) -> bool:
    """
    Más robusto:
    - acepta citacion/citación/convocatoria/comision/omision/servicio
    - y acepta 'otro establecimiento' o abreviados
    """
    c = c_norm
    es_llamado = any(k in c for k in ("citacion", "convocatoria", "comision", "omision", "servicio"))
    es_otro_est = any(k in c for k in ("otro establecimiento", "otros establecimientos", "otro est", "establec"))
    return es_llamado and es_otro_est

def _es_art(c_norm: str) -> bool:
    """
    IMPORTANTÍSIMO:
    'particular' contiene 'art', por eso NO usamos 'art in c'.
    Detectamos ART como palabra o formas típicas: 'licencia art', 'por art', 'art.'
    """
    c = c_norm
    if re.search(r"\bart\b", c):   # palabra ART
        return True
    if "licencia art" in c or "por art" in c or "art." in c:
        return True
    return False



def _causa_bucket(causa_norm: str) -> str:
    c2 = causa_norm

    # ✅ específicos primero (evita falsos positivos)
    # ART: palabra completa (art) para no confundir con "pARTiculares"
    if re.search(r"\bart\b", c2):
        return "art"

    if "paro" in c2:
        return "paro"
    if "duelo" in c2:
        return "duelo"
    if _is_preexamen(c2):
        return "preexamen"
    if "examen" in c2:
        return "examen"

    if "enfermedad personal" in c2:
        return "enfermedad_personal"
    if "enfermedad familiar" in c2:
        return "enfermedad_familiar"

    # ✅ particulares antes que cualquier substring raro
    if "particular" in c2:
        return "particulares"

    if _es_citacion_otro_est(c2):
        return "convocatoria_otros_establecimientos"

    if "injustificada" in c2:
        return "injustificadas"

    if "licencia extraordinaria" in c2:
        return "licencia_extraordinaria"

    return "otras"

def _color_for_causa(causa: str) -> str:
    c = _normalizar_texto(causa)
    if _es_citacion_otro_est(c):
        return "#28a745"  # verde
    return "#dc3545"      # rojo

LIMITES_ANUALES = {
    "preexamen": 12,
    "enfermedad_personal": 25,
    "enfermedad_familiar": 20,
    "particulares": 6,
}

def _contar_por_bucket_docente_anio(docente_id_raw, referencia_fecha=None):
    """
    Cuenta consumos por bucket en el año (para topes/alertas y SET4).
    """
    docente_id = _maybe_oid(docente_id_raw)
    y1, y2 = _year_bounds(referencia_fecha)

    q = {"docente_id": docente_id, "fecha": {"$gte": y1.isoformat(), "$lte": y2.isoformat()}}

    cont = {
        "preexamen": 0,
        "enfermedad_personal": 0,
        "enfermedad_familiar": 0,
        "particulares": 0,
        "citacion": 0,
        "paro": 0,
        "art": 0,
        "duelo": 0,
        "examen": 0,
        "licencia_extraordinaria": 0,
        "injustificadas": 0,
        "otras": 0,
    }

    meses_particulares = {}  # yyyy-mm -> cantidad

    for ins in COL_INASISTENCIAS.find(q):
        causa_norm = _norm(ins.get("causa") or "")
        bucket = _causa_bucket(causa_norm)

        if bucket in cont:
            cont[bucket] += 1
        else:
            cont["otras"] += 1

        if bucket == "particulares":
            d = _parse_date(ins.get("fecha"))
            if d:
                key = f"{d.year}-{d.month:02d}"
                meses_particulares[key] = meses_particulares.get(key, 0) + 1

    return cont, meses_particulares

def _limites_restantes(docente_id_raw, referencia_fecha=None):
    """
    Retorna un dict con:
      - 'restantes': dict(bucket -> cantidad restante en el año o None si no aplica)
      - 'particulares_mes_lleno': dict('YYYY-MM' -> bool) indicando si ya hay una inasistencia en ese mes
      - 'usados' y 'meses_particulares' para información adicional
    """
    cont, meses_particulares = _contar_por_bucket_docente_anio(docente_id_raw, referencia_fecha=referencia_fecha)

    restantes = {}
    # Para buckets definidos en LIMITES_ANUALES, calculamos lo que queda; si no está definido, ponemos None
    for bucket in cont.keys():
        if bucket in LIMITES_ANUALES:
            top = LIMITES_ANUALES.get(bucket, 0)
            usados = cont.get(bucket, 0)
            restantes[bucket] = max(top - usados, 0)
        else:
            restantes[bucket] = None

    # Map de meses con particulares ya ocupados (True si hay al menos 1 inasistencia en ese mes)
    particulares_mes_lleno = {k: (v >= 1) for k, v in meses_particulares.items()}

    return {
        "restantes": restantes,
        "particulares_mes_lleno": particulares_mes_lleno,
        "usados": cont,
        "meses_particulares": meses_particulares,
    }
   

def _no_laborables_set(anio: int):
    """
    Set de fechas ISO 'YYYY-MM-DD' NO laborables (feriados + suspensiones).
    """
    desde = date(anio, 1, 1).isoformat()
    hasta = date(anio, 12, 31).isoformat()

    s = set()
    for x in COL_CALENDARIO_ESCOLAR.find({"fecha": {"$gte": desde, "$lte": hasta}}):
        f = (x.get("fecha") or "").strip()
        if f:
            s.add(f)
    return s

def get_dias_habiles(anio, mes, no_laborables=None):
    """
    Lista de fechas (date) hábiles L-V del mes, excluyendo no_laborables.
    """
    no_laborables = no_laborables or set()

    dias = []
    cal = calendar.Calendar(firstweekday=0)  # 0=Lunes
    for d in cal.itermonthdates(anio, mes):
        if d.month != mes:
            continue
        if d.weekday() < 5 and d.isoformat() not in no_laborables:
            dias.append(d)
    return dias

def dias_base_mes_para_docente(docente, anio, mes, no_laborables=None):
    """
    Denominador correcto del mes:
    - Grupo A (todos menos PROFESOR solo): todos los días hábiles reales del mes
    - PROFESOR solo: sólo los días hábiles que caen en weekdays donde tiene horas
    """
    no_laborables = no_laborables or set()
    dias_habiles = get_dias_habiles(anio, mes, no_laborables=no_laborables)

    if docente_concurre_todos_los_dias(docente):
        return len(dias_habiles)

    dias_con_horas = dias_semana_con_horas_docente(docente)
    if not dias_con_horas:
        return 0

    return sum(1 for d in dias_habiles if d.weekday() in dias_con_horas)

def docente_esperado_en_fecha(docente, fdate, no_laborables=None):
    """
    True si el docente debería concurrir ese día (para cálculo diario).
    - Si el día es no laborable => False para todos
    - Grupo A => True en L-V
    - PROFESOR solo => True si weekday está en sus días con horas
    """
    no_laborables = no_laborables or set()

    # Día no laborable => nadie "esperado"
    if fdate.isoformat() in no_laborables:
        return False

    # Grupo A => concurre todos los días  hábles 
    if docente_concurre_todos_los_dias(docente):
        return fdate.weekday() < 5  # L-V

    # PROFESOR solo => depende de su carga horaria (weekdays con horas)
    return fdate.weekday() in dias_semana_con_horas_docente(docente)


def norm_curso(curso: str) -> str:
    """
    Normaliza cursos para que queden consistentes.
    Acepta: '1A', '1°A', '1ºA', '1 A' -> devuelve '1°A'
            '6B' -> '6°B'
    Si no matchea, devuelve strip tal cual.
    """
    s = (curso or "").strip().upper()
    s = s.replace("º", "°")
    s = re.sub(r"\s+", "", s)  # saca espacios

    m = re.match(r"^(\d+)(°)?([A-Z])$", s)
    if m:
        n = m.group(1)
        letra = m.group(3)
        return f"{n}°{letra}"
    return (curso or "").strip()

def motivo_salida_valido(raw: str) -> str:
    """
    Devuelve motivo limpio o '' si es un placeholder.
    Evita que al editar se marque como baja por error.
    """
    s = (raw or "").strip().upper()
    placeholders = {
        "", "-", "—", "SELECCIONE", "SELECCIONE...", "SELECCIONAR",
        "NINGUNO", "N/A", "NO", "SIN"
    }
    if s in placeholders:
        return ""
    return s

def es_alta_real(escuela_procedencia: str) -> bool:
    """
    Alta real = viene de otra escuela (no EP91) y no está vacío.
    """
    s = (escuela_procedencia or "").strip().upper()
    if not s:
        return False
    # detecta variantes de EP 91
    if "EP" in s and "91" in s:
        return False
    if "E.P" in s and "91" in s:
        return False
    return True

def _es_procedencia_externa(valor):
    """
    Devuelve True si la escuela de procedencia NO es EP 91.
    Vacío o EP 91 => matrícula inicial (no alta real)
    """
    v = (valor or "").strip().upper()
    if not v:
        return False

    v = v.replace("N°", "N").replace("Nº", "N") 

    if "EP" in v and "91" in v:
        return False
    if "E.P." in v and "91" in v:
        return False
    if "E.P" in v and "91" in v:
        return False

    return True

def periodos_mar2026_feb2027():
    # 12 meses: 2026-03 ... 2027-02
    out = []
    y, m = 2026, 3
    for _ in range(12):
        out.append(f"{y:04d}-{m:02d}")
        m += 1
        if m == 13:
            m = 1
            y += 1
    return out

def label_periodo(p):
    # p = "YYYY-MM"
    meses = {
        1:"Ene",2:"Feb",3:"Mar",4:"Abr",5:"May",6:"Jun",
        7:"Jul",8:"Ago",9:"Sep",10:"Oct",11:"Nov",12:"Dic"
    }
    y = int(p[:4]); m = int(p[5:7])
    return f"{meses.get(m,'Mes')} {y}"

def ordenar_curso_key(curso_str: str):
    """
    Ordena tipo: 1°A, 1 A, 1A, 2°B...
    """
    s = (curso_str or "").strip().upper().replace("º", "").replace("°", "").replace(" ", "")
    # ejemplo: "1A"
    num = 99
    sec = "Z"
    if len(s) >= 2 and s[0].isdigit():
        try:
            num = int(s[0])
        except:
            num = 99
        sec = s[1]
    return (num, sec, s)

def _orden_alumno(a):
    """
    Orden:
      1) Turno mañana (A) -> 0, turno tarde (B) -> 1, otros -> 2
      2) Grado 1..6
      3) Sección (A/B)
      4) Apellido, Nombre
    """
    curso = (a.get("curso") or "").upper().replace("º", "°").strip()
    turno_rank = 2
    seccion = ""
    grado = 99

    # Detectamos A/B como secciones válidas
    # Importante: asumimos formato limpio tipo "1° A", "2° B", etc.
    if "A" in curso:
        seccion = "A"
    if "B" in curso:
        # si llegara a tener "A" y "B", gana B sólo si corresponde
        # pero en tu caso no pasa; es defensivo
        if curso.endswith("B") or " B" in curso:
            seccion = "B"

    # Turno por sección
    if seccion == "A":
        turno_rank = 0  # mañana
    elif seccion == "B":
        turno_rank = 1  # tarde

    # Grado (1..6)
    for g in ("1", "2", "3", "4", "5", "6"):
        if curso.startswith(g):
            grado = int(g)
            break

    return (
        turno_rank,
        grado,
        seccion,
        (a.get("apellido") or "").upper(),
        (a.get("nombre") or "").upper()
    )

# ----------------- RESUMEN EDADES POR CURSO -----------------

def _orden_curso(curso: str):
    """
    Ordena cursos como:
      Turno mañana (A) 1°A..6°A, luego turno tarde (B) 1°B..6°B, luego el resto.
    """
    c = (curso or "").upper().replace("º", "°").replace(" ", "")
    turno = 2
    grado = 99
    seccion = ""

    if c[:1].isdigit():
        try:
            grado = int(c[0])
        except ValueError:
            grado = 99

    if "A" in c:
        turno = 0
        seccion = "A"
    elif "B" in c:
        turno = 1
        seccion = "B"

    return (turno, grado, seccion, c)



MESES_ES = [ 
    None,          # índice 0 (no se usa)
    "Enero", 
    "Febrero",
    "Marzo",
    "Abril",
    "Mayo",
    "Junio",
    "Julio",
    "Agosto",
    "Septiembre",
    "Octubre",
    "Noviembre",
    "Diciembre",
]

CURSOS = ["1º", "2º", "3º", "4º", "5º", "6º"]

def calcular_matricula_mensual(mes, anio):
    """
    Matrícula activa en el mes/anio dado.

    Activo = ingresó antes o durante el mes y
             NO tiene EGRESO ni PASE A OTRA ESCUELA efectivo
             antes o dentro de ese mes.

    Separa por curso (1º..6º) y sección A/B (A = mañana, B = tarde).
    """

    # 1. Rango del mes (fechas NAIVE, sin tz)
    try:
        primer_dia = datetime(anio, mes, 1)
        ultimo_dia = primer_dia + relativedelta(months=1) - timedelta(seconds=1)
    except ValueError:
        # Si vino algo raro en mes/año, usamos la fecha actual
        hoy = today()
        mes = hoy.month
        anio = hoy.year
        primer_dia = datetime(anio, mes, 1)
        ultimo_dia = primer_dia + relativedelta(months=1) - timedelta(seconds=1)

    # 2. Estructura base del parte
    estructura_parte = {}
    for curso in CURSOS:
        estructura_parte[f"{curso} A"] = {"VARONES": 0, "MUJERES": 0, "TOTAL": 0}
        estructura_parte[f"{curso} B"] = {"VARONES": 0, "MUJERES": 0, "TOTAL": 0}

    # 3. Alumnos desde Mongo
    alumnos = mongo.db.alumnos.find({})

    # Helper local para parsear fechas que puedan venir como str o datetime
    def parse_fecha(valor, default=None):
        if isinstance(valor, datetime):
            return valor
        if isinstance(valor, str) and valor.strip():
            try:
                # 'YYYY-MM-DD' o 'YYYY-MM-DDTHH:MM:SS'
                return datetime.fromisoformat(valor.strip())
            except ValueError:
                pass
        return default

    inicio_clases = datetime(1900, 1, 1) 

    for alumno in alumnos:
        # === 3.1 Fechas de ingreso / salida ===
        fecha_ingreso = parse_fecha(alumno.get("fecha_ingreso"), default=inicio_clases)
        fecha_salida  = parse_fecha(alumno.get("fecha_salida"),  default=None)

        if fecha_ingreso is None:
            fecha_ingreso = inicio_clases

        motivo = (alumno.get("motivo_salida") or "").strip().upper()

        # Es baja definitiva si tiene EGRESO o PASE y fecha_salida efectiva
        es_baja_definitiva = (
    fecha_salida is not None
    and fecha_salida <= ultimo_dia
)

    # Activo en el mes si ingresó antes/durante y no tiene baja definitiva
        esta_activo = (fecha_ingreso <= ultimo_dia) and not es_baja_definitiva
        if not esta_activo:
            continue

        # === 3.2 Curso y sección desde "curso" (1°A, 2°B, etc.) ===
        curso_raw = (alumno.get("curso") or "").upper().replace("º", "°").replace(" ", "")
        if not curso_raw:
            continue

        grado_str = None
        for g in ("1", "2", "3", "4", "5", "6"):
            if curso_raw.startswith(g):
                grado_str = f"{g}º"
                break
        if grado_str is None:
            continue

        if "A" in curso_raw:
            seccion = "A"
        elif "B" in curso_raw:
            seccion = "B"
        else:
            continue

        clave_curso = f"{grado_str} {seccion}"
        if clave_curso not in estructura_parte:
            continue

        # === 3.3 Sexo ===
        sexo = (alumno.get("sexo") or "").strip().upper()
        if sexo not in ("M", "F"):
            continue

        if sexo == "M":
            estructura_parte[clave_curso]["VARONES"] += 1
        else:
            estructura_parte[clave_curso]["MUJERES"] += 1

        estructura_parte[clave_curso]["TOTAL"] += 1

    # 4. Totales por turno y general
    totales = defaultdict(lambda: {"VARONES": 0, "MUJERES": 0, "TOTAL": 0})
    for curso_seccion, datos in estructura_parte.items():
        if curso_seccion.endswith(" A"):
            turno = "MAÑANA"
        elif curso_seccion.endswith(" B"):
            turno = "TARDE"
        else:
            continue

        totales[turno]["VARONES"] += datos["VARONES"]
        totales[turno]["MUJERES"] += datos["MUJERES"]
        totales[turno]["TOTAL"]   += datos["TOTAL"]

    totales["GENERAL"]["VARONES"] = totales["MAÑANA"]["VARONES"] + totales["TARDE"]["VARONES"]
    totales["GENERAL"]["MUJERES"] = totales["MAÑANA"]["MUJERES"] + totales["TARDE"]["MUJERES"]
    totales["GENERAL"]["TOTAL"]   = totales["MAÑANA"]["TOTAL"]   + totales["TARDE"]["TOTAL"]

    # 5. Lista de cursos para la plantilla
    lista_cursos = []
    for curso in CURSOS:
        lista_cursos.append({
            "curso":  curso,
            "manana": estructura_parte[f"{curso} A"],
            "tarde":  estructura_parte[f"{curso} B"],
        })

    # Nombre del mes en castellano (MESES_ES debe estar definido arriba)
    nombre_mes = MESES_ES[mes]

    return { 
        "mes": nombre_mes,
        "mes_numero": mes,
        "anio": anio,
        "fecha_emision": today().strftime("%d/%m/%Y"),
        "cursos": lista_cursos,
        "totales": totales,
    }

def _anio_range(anio: int):
    desde = datetime(anio, 1, 1, 0, 0, 0)
    hasta = datetime(anio + 1, 1, 1, 0, 0, 0)
    return desde, hasta

def _str_norm(x: str) -> str:
    return (x or "").strip().upper()

def _es_ep91(txt: str) -> bool:
    t = _str_norm(txt)
    # contemplamos variantes: "E.P. 91", "EP 91", "E.P N° 91", etc.
    return bool(re.search(r"\bE\.?\s*P\.?\s*(N|N°|NUM|NUMERO)?\s*\.?\s*91\b", t))

def _es_alta_real(mov: dict) -> bool:
    """
    Alta real: escuela_origen existe y NO es EP91 (ni vacío).
    Si está vacío o es EP91 => matrícula inicial.
    """
    esc = mov.get("escuela_origen") or mov.get("escuela_procedencia") or ""
    if not esc.strip():
        return False
    if _es_ep91(esc):
        return False
    return True

@app.route("/resumen/movimientos")
def resumen_movimientos():
    # año seleccionado
    anio_param = (request.args.get("anio") or "").strip()
    try:
        anio = int(anio_param) if anio_param else date.today().year
    except ValueError:
        anio = date.today().year

    d1, d2 = _anio_range(anio)

    movs = list(COL_MOVIMIENTOS.find({
        "fecha": {"$gte": d1, "$lt": d2}
    }).sort([("fecha", -1)]))

    entradas_reales = []
    matricula_inicial = []
    pases = []
    egresos = []
    cambios_turno = []
    otras_bajas = []

    for m in movs:
        tipo = _str_norm(m.get("tipo"))
        motivo = _str_norm(m.get("motivo") or m.get("motivo_salida"))

        if tipo == "ALTA":
            if _es_alta_real(m):
                entradas_reales.append(m)
            else:
                matricula_inicial.append(m)

        elif tipo == "CAMBIO_TURNO":
            cambios_turno.append(m)

        elif tipo in ("BAJA", "SALIDA"):
            # clasificamos por motivo
            if "PASE" in motivo:
                pases.append(m)
            elif "EGRESO" in motivo:
                egresos.append(m)
            else:
                otras_bajas.append(m)
        else:
            otras_bajas.append(m)

    # años disponibles (para el selector)
    anios_disponibles = sorted(
        { (m.get("fecha").year if isinstance(m.get("fecha"), datetime) else None)
          for m in COL_MOVIMIENTOS.find({}, {"fecha": 1}) },
        reverse=True
    )
    anios_disponibles = [a for a in anios_disponibles if a]

    return render_template(
        "resumen_movimientos.html",
        anio=anio,
        anios_disponibles=anios_disponibles,
        entradas_reales=entradas_reales,
        matricula_inicial=matricula_inicial,
        pases=pases,
        egresos=egresos,
        cambios_turno=cambios_turno,
        otras_bajas=otras_bajas,
    )

# --- SET4 helpers/route/pdf/mail ---
def _fetch_set4_context(docente_id, desde, hasta):
    d = COL_DOCENTES.find_one({"_id": ObjectId(docente_id)})
    if not d: return None, None, None

    # Inicializamos todos los contadores que tu calendario espera ver
    totales = {
        "enfermedad_personal": 0,
        "enfermedad_familiar": 0,
        "particulares": 0,
        "citacion": 0,
        "injustificadas": 0,
        "duelo": 0,
        "examen": 0,
        "paro": 0,
        "pre_examen": 0,
        "ART": 0,
        "otras": 0,
        "suma": 0
    }

    q = {"docente_id": ObjectId(docente_id), "fecha": {"$gte": desde, "$lte": hasta}}
    inasistencias_lista = []
    
    for ins in COL_INASISTENCIAS.find(q).sort("fecha", 1):
        causa = (ins.get("causa") or "").lower()
        
        # Lógica de discriminación detallada
        if "personal" in causa and "enfermedad" in causa:
            totales["enfermedad_personal"] += 1
        elif "familiar" in causa and "enfermedad" in causa:
            totales["enfermedad_familiar"] += 1
        elif "particular" in causa:
            totales["particulares"] += 1
        elif "citacion" in causa or "citación" in causa:
            totales["citacion"] += 1
        elif "injustificada" in causa:
            totales["injustificadas"] += 1
        elif "duelo" in causa:
            totales["duelo"] += 1
        elif "examen" in causa and "pre" not in causa:
            totales["examen"] += 1
        elif "pre" in causa and "examen" in causa:
            totales["pre_examen"] += 1
        elif "paro" in causa:
            totales["paro"] += 1
        elif "art" in causa:
            totales["ART"] += 1
        else:
            totales["otras"] += 1
        
        inasistencias_lista.append(ins)

    totales["suma"] = sum(v for k, v in totales.items() if k != "suma")
    
    periodo = {"desde": desde, "hasta": hasta}
    return d, periodo, (totales, inasistencias_lista)

def _fetch_set4_context_oficial(docente_id, anio):
    # 1. Buscamos al docente
    d = COL_DOCENTES.find_one({"_id": ObjectId(docente_id)})
    if not d: return None, None, None

    desde = f"{anio}-01-01"
    hasta = f"{anio}-12-31"
    
    # 2. Buscamos todas sus inasistencias del año
    q = {"docente_id": ObjectId(docente_id), "fecha": {"$gte": desde, "$lte": hasta}}
    
    # Inicializamos los 4 grupos oficiales + el total
    totales = {
        "enfermedad": 0,      # Aquí sumaremos Personal y Familiar
        "privadas": 0,        # Aquí las Causas Particulares
        "otras": 0,           # Aquí: Paro, Duelo, Examen, ART, etc.
        "injustificadas": 0,  # Injustificadas
        "suma": 0
    }

    inasistencias_lista = []
    for ins in COL_INASISTENCIAS.find(q).sort("fecha", 1):
        causa = (ins.get("causa") or "").lower()
        
        if "enfermedad" in causa:
            totales["enfermedad"] += 1
        elif "particular" in causa:
            totales["privadas"] += 1
        elif "injustificada" in causa:
            totales["injustificadas"] += 1
        else:
            # Todo lo demás (Paro, Citación, Duelo, etc.) va a "Otras"
            totales["otras"] += 1
            
        inasistencias_lista.append(ins)

    totales["suma"] = totales["enfermedad"] + totales["privadas"] + totales["otras"] + totales["injustificadas"]
    
    periodo = {"desde": f"01/01/{anio}", "hasta": f"31/12/{anio}"}
    return d, periodo, (totales, inasistencias_lista)

def _aux_historial_query_from_args(args):
    q = {}

    aux_id = (args.get("auxiliar_id") or "").strip()
    desde  = (args.get("desde") or "").strip()
    hasta  = (args.get("hasta") or "").strip()
    causa  = (args.get("causa") or "").strip()

    if aux_id and aux_id.upper() != "TODOS":
        q["auxiliar_id"] = _maybe_oid(aux_id)

    if desde and hasta:
        q["fecha"] = {"$gte": desde, "$lte": hasta}
    elif desde:
        q["fecha"] = {"$gte": desde}
    elif hasta:
        q["fecha"] = {"$lte": hasta}

    if causa and causa.upper() != "TODAS":
        q["causa"] = {"$regex": causa, "$options": "i"}

    return q


def _contar_por_bucket_aux_anio(auxiliar_id, referencia_fecha):
    """
    Copia funcional de tu _contar_por_bucket_docente_anio, pero leyendo COL_INASISTENCIAS_AUX.
    Devuelve: (cont_anual, meses_particulares)
    """
    anio = int(referencia_fecha.year)
    desde_iso = date(anio, 1, 1).isoformat()
    hasta_iso = date(anio, 12, 31).isoformat()

    cont = {}
    meses_particulares = {}

    q = {"auxiliar_id": auxiliar_id, "fecha": {"$gte": desde_iso, "$lte": hasta_iso}}
    for ins in COL_INASISTENCIAS_AUX.find(q, {"fecha": 1, "causa": 1}):
        f = _parse_date(ins.get("fecha"))
        if not f:
            continue
        causa_norm = _norm((ins.get("causa") or "").strip())
        bucket = _causa_bucket(causa_norm)

        cont[bucket] = cont.get(bucket, 0) + 1

        if bucket == "particulares": 
            key_mes = f"{f.year}-{f.month:02d}"
            meses_particulares[key_mes] = meses_particulares.get(key_mes, 0) + 1

    return cont, meses_particulares




# =================================================================
# BLOQUE : RUTAS
# =================================================================

@app.route('/')
def index(): 
    user = get_current_user()
    
    # Obtener un resumen de docentes y cursos 
    docentes_count = COL_DOCENTES.count_documents({})
    cursos_count = COL_CURSOS.count_documents({})
    
    # Obtener el estado actual del SET4 (asumiendo que hay una configuración para el año)
    config = COL_CONFIG.find_one({"_id": "config_general"})
    set4_estado = config.get("set4_estado", "No iniciado") if config else "No iniciado"
    
    # Obtener alertas (vencimientos de licencias, etc.)
    # Esto es una simulación. En realidad se haría una consulta más compleja.
    alertas = []
    
    # Simulación de alerta de vencimiento de licencias
    docentes_con_licencia = COL_DOCENTES.find({"licencia_vto": {"$exists": True, "$ne": ""}})
    for doc in docentes_con_licencia:
        try:
            vto_date = datetime.strptime(doc['licencia_vto'], '%Y-%m-%d').date()
            if vto_date < date.today() + timedelta(days=30):
                dias_restantes = (vto_date - date.today()).days
                alertas.append({
                    "tipo": "Vencimiento",
                    "mensaje": f"La licencia de {doc['nombre']} vence en {dias_restantes} días ({doc['licencia_vto']}).",
                    "nivel": "warning" if dias_restantes > 0 else "danger"
                })
        except ValueError:
            # Ignorar si el formato de fecha es incorrecto
            pass

    return render_template('index.html', 
                           user=user, 
                           docentes_count=docentes_count, 
                           cursos_count=cursos_count,
                           set4_estado=set4_estado,
                           alertas=alertas)

@app.route("/mapa/escuela")
def ver_mapa_escuela():
    """
    Abre en una nueva pestaña el mapa centrado en la escuela.
    """
    direccion = "Tomás Edison 2164, Isidro Casanova, Buenos Aires, Argentina"
    url = f"https://www.google.com/maps/search/?api=1&query={quote(direccion)}"
    return redirect(url)
  
@app.route("/calendario_escolar", methods=["GET", "POST"])
def calendario_escolar():
    # Año a mostrar
    anio_param = (request.args.get("anio") or "").strip()
    try:
        anio = int(anio_param) if anio_param else date.today().year
    except ValueError:
        anio = date.today().year

    if request.method == "POST":
        fecha = (request.form.get("fecha") or "").strip()  # YYYY-MM-DD
        tipo = (request.form.get("tipo") or "").strip().upper()  # FERIADO / SUSPENSION
        motivo = (request.form.get("motivo") or "").strip().upper()

        if fecha and tipo in ("FERIADO", "SUSPENSION"):
            # upsert por fecha (si ya existe, lo actualiza)
            COL_CALENDARIO_ESCOLAR.update_one(
                {"fecha": fecha},
                {"$set": {"fecha": fecha, "tipo": tipo, "motivo": motivo}},
                upsert=True
            )

        return redirect(url_for("calendario_escolar", anio=anio))

    # listar solo del año
    desde = date(anio, 1, 1).isoformat()
    hasta = date(anio, 12, 31).isoformat()

    items = list(
        COL_CALENDARIO_ESCOLAR.find({"fecha": {"$gte": desde, "$lte": hasta}})
        .sort("fecha", 1)
    )

    # para template
    items_json = []
    for x in items:
        items_json.append({
            "_id": str(x.get("_id")), 
            "fecha": x.get("fecha", ""),
            "tipo": x.get("tipo", ""),
            "motivo": x.get("motivo", ""),
        })

    return render_template("calendario_escolar.html", anio=anio, items=items_json)


@app.route("/calendario_escolar/<id>/eliminar", methods=["POST"])
def eliminar_calendario_escolar(id):
    try:
        COL_CALENDARIO_ESCOLAR.delete_one({"_id": ObjectId(id)})
    except Exception:
        pass
    # volver al año actual (o podés mandar anio hidden en form si querés)
    return redirect(url_for("calendario_escolar"))

# ----------------- DOCENTES -----------------

@app.route("/docentes")
def listar_docentes():
    docentes = []
    for d in COL_DOCENTES.find().sort([("apellido", 1), ("nombre", 1)]):
        dj = to_json(d)
        if not isinstance(dj.get("carga_horaria"), list) or len(dj.get("carga_horaria", [])) != 5:
            dj["carga_horaria"] = matriz_5x5_vacia()
        docentes.append(dj)
    return render_template("docentes.html", docentes=docentes)

@app.route("/docentes/nuevo", methods=["POST"])
def nuevo_docente():
    data = request.form.to_dict()

    # Cargos múltiples (select multiple)
    cargos = sorted(set(c.strip() for c in request.form.getlist("cargo") if c.strip()))
    if cargos:
        data["cargo"] = ", ".join(cargos)
    else:
        data["cargo"] = ""

    data.setdefault("situacion", "")
    data["carga_horaria"] = matriz_5x5_vacia()

    COL_DOCENTES.insert_one(data)
    return redirect(url_for("listar_docentes"))

@app.route("/docentes/<id>/editar", methods=["POST"])
def editar_docente(id):
    updates = request.form.to_dict()

    # ✅ siempre procesar cargo si vino el campo (aunque quede vacío)
    if "cargo" in request.form:
        cargos = [c.strip() for c in request.form.getlist("cargo") if c.strip()]
        updates["cargo"] = ", ".join(cargos) if cargos else ""

    updates.pop("carga_horaria", None)

    try:
        COL_DOCENTES.update_one({"_id": ObjectId(id)}, {"$set": updates})
    except Exception:
        abort(400)

    return redirect(url_for("listar_docentes"))



@app.route("/docentes/<id>/eliminar", methods=["POST"])
def eliminar_docente(id):
    COL_DOCENTES.delete_one({"_id": ObjectId(id)})
    COL_INASISTENCIAS.delete_many({"docente_id": id})
    COL_CALIFICACIONES.delete_many({"docente_id": id})
    COL_ESTADOS_ADMIN.delete_many({"docente_id": id})
    return redirect(url_for("listar_docentes"))

@app.route("/api/docentes")
def api_docentes():
    out = []
    for d in COL_DOCENTES.find().sort([("apellido", 1), ("nombre", 1)]):
        out.append({
            "_id": str(d["_id"]),
            "nombre": d.get("nombre", ""),
            "apellido": d.get("apellido", ""),
            "cargo": d.get("cargo", "")
        })
    return jsonify(out)

@app.route("/docentes/<id>/carga_horaria", methods=["POST"]) 
def docente_carga_horaria(id): 
    payload = request.get_json(silent=True) or {}
    matriz = payload.get("carga_horaria")
    if not matriz or not isinstance(matriz, list) or len(matriz) != 5 or any(len(r) != 5 for r in matriz):
        return jsonify({"error": "Formato inválido. Se espera matriz 5x5."}), 400
    COL_DOCENTES.update_one({"_id": ObjectId(id)}, {"$set": {"carga_horaria": matriz}})
    return jsonify({"status": "ok"})

@app.route("/docentes/<id>/set4")
def docente_set4(id):
    try:
        _ = ObjectId(id)
    except:
        abort(404)
    
    # Obtenemos el año del parámetro 'anio' o de la fecha 'desde'
    anio = request.args.get("anio")
    desde = request.args.get("desde") # Por si viene de un filtro de fechas
    
    if not anio:
        if desde:
            anio = desde.split("-")[0] # Extrae '2025' de '2025-01-01'
        else:
            anio = date.today().year

    # AHORA SI: Pasamos solo 2 argumentos como espera la función
    d, periodo, pack = _fetch_set4_context_oficial(id, anio)
    
    if not d: 
        abort(404)
        
    totales, inasistencias = pack
    
    return render_template("set4_calificacion.html",
                           docente=d, 
                           periodo=periodo,
                           totales=totales, 
                           inasistencias=inasistencias)


@app.route("/docentes/<id>/inasistencias_anuales")
def docente_inasistencias_anuales(id): 
    """
    Hoja anual de inasistencias para un docente (formato SET4):
    - Calendario L-V (enero–diciembre) del año elegido
    - Colores por día según causa (rojo / verde)
    - Resumen numérico tipo punto 14 del SET4
    NOTA: El calendario visual NO excluye feriados/suspensiones (SET4 mantiene grilla).
    """
    try:
        oid = ObjectId(id)
    except Exception:
        abort(404)

    anio_param = (request.args.get("anio") or "").strip()
    try:
        anio = int(anio_param) if anio_param else date.today().year
    except ValueError:
        anio = date.today().year

    docente = COL_DOCENTES.find_one({"_id": oid})
    if not docente:
        abort(404)

    desde_iso = date(anio, 1, 1).isoformat()
    hasta_iso = date(anio, 12, 31).isoformat()

    # Resumen numérico (SET4)
    d_set4, periodo, pack = _fetch_set4_context(id, desde_iso, hasta_iso)
    if not d_set4:
        totales = {
            "enfermedad_personal": 0,
            "enfermedad_familiar": 0,
            "particulares": 0,
            "citacion": 0,
            "injustificadas": 0,
            "duelo": 0,
            "examen": 0,
            "paro": 0,
            "pre_examen": 0,
            "otras": 0,
            "suma": 0,
        }
        lista_inasistencias = []
        periodo = {"desde": desde_iso, "hasta": hasta_iso}
    else:
        totales, lista_inasistencias = pack

    # Mapa (mes, día) -> color
    faltas_por_fecha = {}
    q = {"docente_id": _maybe_oid(id), "fecha": {"$gte": desde_iso, "$lte": hasta_iso}}
    for ins in COL_INASISTENCIAS.find(q):
        f = _parse_date(ins.get("fecha"))
        if not f:
            continue
        causa = (ins.get("causa") or "").strip()
        faltas_por_fecha[(f.month, f.day)] = _color_for_causa(causa)

    # Calendario anual: grilla L-V completa (SET4)
    meses_data = []
    for mes in range(1, 13):
        dias_habiles = get_dias_habiles(anio, mes)  # OJO: sin no_laborables para mantener grilla

        filas = []
        fila_actual = [None] * 5  # L M M J V
        last_weekday = None

        for f in dias_habiles:
            wd = f.weekday()  # 0..4

            # Si vuelve a lunes, cortamos semana
            if last_weekday is not None and wd == 0:
                if any(c is not None for c in fila_actual):
                    filas.append(fila_actual)
                fila_actual = [None] * 5

            fila_actual[wd] = {
                "dia": f.day,
                "color": faltas_por_fecha.get((mes, f.day)),
            }
            last_weekday = wd

        if any(c is not None for c in fila_actual):
            filas.append(fila_actual)

        meses_data.append({
            "num": mes,
            "nombre": MESES_MAYUS.get(mes, str(mes)),
            "filas": filas,
        })

    fecha_impresion = date.today()
    periodo = {"desde": desde_iso, "hasta": hasta_iso}

    return render_template(
        "docente_inasistencias_calendario.html",
        docente=docente,
        anio=anio,
        meses=meses_data,
        totales=totales,
        periodo=periodo,
        fecha_impresion=fecha_impresion,
    )

# ----------------- INASISTENCIAS (robusto) -----------------

@app.route("/inasistencias")
def ver_inasistencias():
    return render_template("inasistencias.html")


@app.route("/api/inasistencias/<id>", methods=["GET"])
def api_inasistencia_get(id):
    try:
        oid = ObjectId(id)
    except Exception:
        return jsonify(ok=False, error="ID inválido"), 400

    ins = COL_INASISTENCIAS.find_one({"_id": oid})
    if not ins:
        return jsonify(ok=False, error="Inasistencia no encontrada"), 404

    ins["_id"] = str(ins["_id"])
    ins["docente_id"] = str(ins.get("docente_id"))
    return jsonify(ok=True, data=ins)


@app.route("/api/inasistencias/<id>", methods=["PUT"])
def api_inasistencia_update(id):
    try:
        oid = ObjectId(id)
    except Exception:
        return jsonify(ok=False, error="ID inválido"), 400

    data = request.get_json(silent=True) or {}

    updates = {}
    for campo in ("fecha", "causa", "observaciones"):
        if campo in data and data[campo] is not None:
            if campo == "fecha":
                d = _parse_date(data.get("fecha"))
                if not d:
                    return jsonify(ok=False, error="Fecha inválida"), 400
                updates["fecha"] = d.isoformat()
            else:
                updates[campo] = (data.get(campo) or "").strip()

    # suplente opcional
    sup = data.get("suplente_info") or data.get("suplente") or {}
    if isinstance(sup, dict):
        sup_clean = {
            "nombre": (sup.get("nombre") or "").strip(),
            "dni": (sup.get("dni") or "").strip(),
            "curso": (sup.get("curso") or "").strip(),
            "asignatura": (sup.get("asignatura") or "").strip(),
        }
        sup_clean = {k: v for k, v in sup_clean.items() if v}
        updates["suplente_info"] = sup_clean

    if not updates:
        return jsonify(ok=False, error="Sin cambios"), 400

    COL_INASISTENCIAS.update_one({"_id": oid}, {"$set": updates})
    return jsonify(ok=True)


@app.route("/api/inasistencias/<id>", methods=["DELETE"])
def api_inasistencia_delete(id):
    try:
        oid = ObjectId(id)
    except Exception:
        return jsonify(ok=False, error="ID inválido"), 400

    res = COL_INASISTENCIAS.delete_one({"_id": oid})
    return jsonify(ok=bool(res.deleted_count), deleted=int(res.deleted_count))


# SOLO POST: crear inasistencias (desde/hasta)
@app.route("/api/inasistencias", methods=["POST"])
def api_inasistencias():
    data = request.get_json(silent=True) or {}

    docente_id_raw = data.get("docente_id") or data.get("docente")
    if not docente_id_raw:
        return jsonify(ok=False, error="Docente requerido."), 400

    docente_id = _maybe_oid(docente_id_raw)

    desde = _parse_date(data.get("desde") or data.get("fecha"))
    hasta = _parse_date(data.get("hasta") or data.get("fecha"))

    if not desde:
        return jsonify(ok=False, error="Fecha 'desde' requerida."), 400
    if not hasta:
        hasta = desde
    if hasta < desde:
        desde, hasta = hasta, desde

    causa = (data.get("causa") or "").strip()
    if not causa:
        return jsonify(ok=False, error="Causa requerida."), 400

    observ = (data.get("observaciones") or "").strip()

    suplente_info = {
        "nombre": (data.get("sup_nombre") or data.get("suplente_nombre") or "").strip(),
        "dni": (data.get("sup_dni") or "").strip(),
        "curso": (data.get("sup_curso") or "").strip(),
        "asignatura": (data.get("sup_asignatura") or "").strip(),
    }
    suplente_info = {k: v for k, v in suplente_info.items() if v}

    causa_norm = _norm(causa)
    bucket = _causa_bucket(causa_norm)

    # ---- Topes y reglas ----
    cont_anual, meses_particulares = _contar_por_bucket_docente_anio(docente_id, referencia_fecha=desde)

    warning = None

    # ✅ REGLA ESTRICTA: CAUSAS PARTICULARES = 1 DÍA POR MES y máx 6 al año
    if bucket == "particulares":
        # 1) no permito rango multi-día
        if desde != hasta:
            return jsonify(ok=False, error="Causas particulares: debe ser UN (1) solo día (1 por mes)."), 400

        # 2) no más de 1 por mes
        key_mes = f"{desde.year}-{desde.month:02d}"
        if meses_particulares.get(key_mes, 0) >= 1:
            return jsonify(ok=False, error="Ya hay una inasistencia por 'causas particulares' en este mes."), 400

        # 3) no más de 6 al año
        if cont_anual.get("particulares", 0) >= LIMITES_ANUALES["particulares"]:
            return jsonify(ok=False, error="Se alcanzó el tope anual de 'causas particulares' (6)."), 400

    # ✅ ADVERTENCIA (NO BLOQUEA) para enfermedad/preexamen si excede el tope
    if bucket in ("enfermedad_personal", "enfermedad_familiar", "preexamen"):
        tope = LIMITES_ANUALES.get(bucket)
        if tope is not None and cont_anual.get(bucket, 0) >= tope:
            warning = f"Docente excedido en esta inasistencia: VER cuadro resumen y alertas ({cont_anual.get(bucket,0)+1}/{tope})."

        # ✅ No permitir fechas futuras (te advierte y NO deja guardar)
    if desde > date.today():
        return jsonify(ok=False, error="Fecha inválida: no se pueden cargar inasistencias futuras."), 400

    # ---- Evitar más de una inasistencia por día (IDEMPOTENTE) ----
    dias_a_insertar = []
    dcur = desde
    while dcur <= hasta:
        fecha_iso = dcur.isoformat()

        existente = COL_INASISTENCIAS.find_one({"docente_id": docente_id, "fecha": fecha_iso})
        if existente:
            # si ya existe exactamente lo mismo, lo tomo como reintento (no error)
            same = (
                (existente.get("causa") or "").strip() == causa and
                (existente.get("observaciones") or "").strip() == observ and
                (existente.get("suplente_info") or {}) == suplente_info
            )
            if same:
                dcur += timedelta(days=1)
                continue

            msg = f"Ya hay una inasistencia cargada para este docente el {dcur.strftime('%d/%m/%Y')}."
            return jsonify(ok=False, error=msg), 400

        dias_a_insertar.append(fecha_iso)
        dcur += timedelta(days=1)
    # ---- Insertar inasistencias ----
        docs = [{
        "docente_id": docente_id,
        "fecha": f,
        "causa": causa,
        "observaciones": observ,
        "suplente_info": suplente_info,
    } for f in dias_a_insertar]

    if docs:
        COL_INASISTENCIAS.insert_many(docs)

    return jsonify(ok=True, inserted=len(docs), warning=warning)


@app.route("/inasistencias/<id>/editar", methods=["GET", "POST"])
def editar_inasistencia(id):
    try:
        oid = ObjectId(id)
    except Exception:
        abort(404)

    ins = COL_INASISTENCIAS.find_one({"_id": oid})
    if not ins:
        abort(404)

    if request.method == "POST":
        data = request.form.to_dict()

        # Normalizamos nombres de campos según lo que guardás en /api_inasistencias
        update = {
            "fecha": data.get("fecha", "").strip(),
            "docente_id": data.get("docente_id", ins.get("docente_id")),
            "causa": data.get("causa", "").strip(),
            "suplente_nombre": data.get("suplente_nombre", "").strip(),
            "suplente_dni": data.get("suplente_dni", "").strip(),
            "suplente_curso": data.get("suplente_curso", "").strip(),
            "observaciones": data.get("observaciones", "").strip(),
        }

        COL_INASISTENCIAS.update_one({"_id": oid}, {"$set": update})
        # Después de editar, te vuelvo al historial, con los mismos filtros que tenías si querés
        return redirect(url_for("historial_inasistencias"))

    # GET → cargo docentes para el combo y muestro plantilla
    docentes = list(COL_DOCENTES.find().sort([("apellido", 1), ("nombre", 1)])) 
    # Convertimos ObjectId a string
    ins["_id"] = str(ins["_id"])
    return render_template("inasistencias_editar.html",
                           inasistencia=ins,
                           docentes=docentes)

# ----------------- HISTORIAL INASISTENCIAS (vista + APIs) -----------------

@app.get("/inasistencias/historial")
def historial_inasistencias():
    if not mongo_ping_ok():
        return render_template("db_down.html"), 503

    docentes = list(COL_DOCENTES.find().sort([("apellido", 1), ("nombre", 1)]))
    docentes = [{"_id": str(d["_id"]), "apellido": d.get("apellido",""), "nombre": d.get("nombre","")} for d in docentes]

    return render_template("historial_inasistencias.html", docentes=docentes)


def _historial_query_from_args(args):
    q = {}

    docente_id = (args.get("docente_id") or "").strip()
    desde = (args.get("desde") or "").strip()
    hasta = (args.get("hasta") or "").strip()
    causa = (args.get("causa") or "").strip()

    # Docente
    if docente_id and docente_id.upper() != "TODOS":
        q["docente_id"] = _maybe_oid(docente_id) 

    # Fechas (guardadas como ISO yyyy-mm-dd)
    if desde and hasta:
        q["fecha"] = {"$gte": desde, "$lte": hasta}
    elif desde:
        q["fecha"] = {"$gte": desde}
    elif hasta:
        q["fecha"] = {"$lte": hasta}

    # Causa
    if causa and causa.upper() != "TODAS":
        # match flexible, case-insensitive
        q["causa"] = {"$regex": causa, "$options": "i"}

    return q


@app.get("/api/historial_lista")
def api_historial_lista():
    if not mongo_ping_ok():
        return jsonify({"ok": False, "error": "db_down"}), 503

    q = _historial_query_from_args(request.args)

    # 1) Traigo todas las inasistencias del query
    ins_list = list(COL_INASISTENCIAS.find(q).sort("fecha", 1))

    # 2) Junto los docente_id (como ObjectId) para resolver nombres en 1 sola query
    docente_oids = []
    for ins in ins_list:
        did = ins.get("docente_id")
        if did:
            try:
                docente_oids.append(_maybe_oid(did))
            except Exception:
                pass

    docente_oids = [d for d in docente_oids if d is not None]

    docentes_map = {}
    if docente_oids:
        for d in COL_DOCENTES.find({"_id": {"$in": docente_oids}}, {"apellido": 1, "nombre": 1, "cargo": 1}):
            docentes_map[str(d["_id"])] = {
                "nombre": d.get("nombre", ""),
                "apellido": d.get("apellido", ""),
                "cargo": d.get("cargo", ""),
            }

    rows = []
    for ins in ins_list:
        did_raw = ins.get("docente_id")
        did_str = ""
        if did_raw is not None:
            try:
                did_str = str(did_raw)
            except Exception:
                did_str = ""

        d = docentes_map.get(did_str, {}) 
        docente_nombre = ""
        if d:
            docente_nombre = f"{d.get('apellido','')}, {d.get('nombre','')}".strip(", ")

        rows.append({
            "_id": str(ins.get("_id")),
            "fecha": ins.get("fecha", ""),
            "causa": ins.get("causa", ""),
            "observaciones": ins.get("observaciones", ""),
            "suplente_info": ins.get("suplente_info") or {},
            "docente_id": did_str,
            "docente_nombre": docente_nombre,
            "edit_url": f"/inasistencias/{str(ins.get('_id'))}/editar",
        })

    return jsonify({"ok": True, "items": rows})

@app.get("/api/historial_resumen")
def api_historial_resumen():
    if not mongo_ping_ok():
        return jsonify({"ok": False, "error": "db_down"}), 503

    q = _historial_query_from_args(request.args)

    por = {
        "enfermedad_personal": 0,
        "enfermedad_familiar": 0,
        "enfermedad_cronica": 0,
        "particulares": 0,
        "citacion_otro_establecimiento": 0,
        "injustificadas": 0,
        "pre_examen": 0,

        "duelo": 0,
        "examen": 0,
        "paro": 0,
        "art": 0,
        "licencia_extraordinaria": 0,
        "otras": 0,
    }

    def bucket_from_causa(causa: str) -> str:
        c = _normalizar_texto(causa or "")
        if "enfermedad personal" in c:
            return "enfermedad_personal"
        if "enfermedad familiar" in c:
            return "enfermedad_familiar"
        if "cronica" in c:
            return "enfermedad_cronica"
        if "causas particulares" in c or ("particular" in c):
            return "particulares"
        if "citacion" in c and "otro" in c and "establecimiento" in c:
            return "citacion_otro_establecimiento"
        if "injust" in c:
            return "injustificadas"
        if "pre" in c and "examen" in c:
            return "pre_examen"
        if "duelo" in c:
            return "duelo"
        if "examen" in c and "pre" not in c:
            return "examen"
        if "paro" in c:
            return "paro"
        if "art" == c or " art " in f" {c} ":
            return "art"
        if "licencia extraordinaria" in c:
            return "licencia_extraordinaria"
        return "otras"

    total = 0
    for ins in COL_INASISTENCIAS.find(q, {"causa": 1}):
        total += 1
        b = bucket_from_causa(ins.get("causa", ""))
        por[b] = por.get(b, 0) + 1

    return jsonify({"ok": True, "total": total, "por_causa": por})

# ----------------- ALUMNOS -----------------
@app.route("/alumnos")
def listar_alumnos():
    # ----------------- PARÁMETROS -----------------
    # Capturamos el año (por defecto 2025)
    anio_busqueda = int(request.args.get("anio_lectivo", 2025))
    
    q = (request.args.get("q") or "").strip()
    curso_sel = (request.args.get("curso") or "").strip() 
    turno_sel = (request.args.get("turno") or "").strip()
    ver_historico = (request.args.get("historico") == "1")

    turnos = ["Mañana", "Tarde"]

    # ----------------- FILTRO BASE -----------------
    # Agregamos el año como condición obligatoria
    filtro = {"anio_lectivo": anio_busqueda}

    # Búsqueda de texto (Si hay búsqueda, la combinamos con el año)
    if q:
        regex = {"$regex": q, "$options": "i"}
        filtro["$and"] = [
            {"anio_lectivo": anio_busqueda},
            {"$or": [
                {"apellido": regex}, 
                {"nombre": regex},
                {"dni": regex},
                {"curso": regex},
                {"apellido_nombre": regex}
            ]}
        ]

    # Filtro por curso / turno
    if curso_sel:
        filtro["curso"] = {"$regex": rf"^\s*{re.escape(curso_sel)}\s*$", "$options": "i"}
    elif turno_sel:
        ts = turno_sel.strip().lower()
        if ts == "mañana":
            filtro["curso"] = {"$regex": r"A\s*$", "$options": "i"}
        elif ts == "tarde":
            filtro["curso"] = {"$regex": r"B\s*$", "$options": "i"}

    # ----------------- CONSULTA A MONGO -----------------
    if ver_historico and curso_sel:
        cond_historico = {
            "$and": [
                {"anio_lectivo": anio_busqueda}, # Siempre filtramos por año
                {"$or": [
                    {"fecha_salida": {"$in": [None, "", False]}},
                    {"curso_origen": curso_sel},
                    {"curso": curso_sel},
                ]}
            ]
        }
        alumnos_cur = app.mongo.alumnos.find(cond_historico)
    else:
        # Combinamos el filtro de activos (si lo usas) con nuestro filtro de año/búsqueda
        query_final = {**filtro_activos(), **filtro}
        alumnos_cur = app.mongo.alumnos.find(query_final)

    alumnos = list(alumnos_cur)

    # ----------------- FLAGS PARA EL TEMPLATE -----------------
    for a in alumnos:
        fs = a.get("fecha_salida")
        a["esta_activo"] = not fs
        a["historico_en_curso"] = False
        if curso_sel:
            if fs and a.get("curso") == curso_sel:
                a["historico_en_curso"] = True
            if a.get("curso_origen") == curso_sel:
                a["historico_en_curso"] = True
        
        mot = (a.get("motivo_salida") or "").strip().upper()
        dest = (a.get("destino_salida") or "").strip()
        curso_dest = (a.get("curso_destino") or "").strip()

        sale_a = ""
        if mot == "CAMBIO DE TURNO":
            sale_a = f"CAMBIO TURNO → {curso_dest}" if curso_dest else "CAMBIO DE TURNO"
        elif mot == "EGRESO":
            sale_a = "EGRESO"
        elif mot == "PASE A OTRA ESCUELA":
            sale_a = f"PASE → {dest}" if dest else "PASE A OTRA ESCUELA"
        elif mot:
            sale_a = f"{mot} → {dest}" if dest else mot
        a["sale_a_str"] = sale_a

    # ----------------- ORDEN -----------------
    alumnos.sort(key=_orden_alumno)

    # ----------------- EDAD / FECHAS (Calculada al año de búsqueda) -----------------
    # Usamos anio_busqueda para que la edad coincida con el ciclo lectivo
    REF = date(anio_busqueda, 6, 30)

    for a in alumnos:
        fn = a.get("fecha_nacimiento") or a.get("fecha_nac")
        if fn:
            try:
                y, m, d = map(int, fn[:10].split("-"))
                nac = date(y, m, d)
                edad = REF.year - nac.year - ((REF.month, REF.day) < (nac.month, nac.day))
                a["edad_30jun"] = edad
                a["fecha_nac_str"] = f"{d:02d}/{m:02d}/{y}"
            except Exception:
                a["edad_30jun"] = ""
        else:
            a["edad_30jun"] = ""

    # Cursos para el combo
    cursos = sorted([c for c in app.mongo.alumnos.distinct("curso") if c])

    # ----------------- RENDER -----------------
    return render_template(
        "alumnos.html",
        alumnos=alumnos,
        q=q,
        curso_sel=curso_sel,
        cursos=cursos,
        turno_sel=turno_sel,
        turnos=turnos,
        ver_historico=ver_historico,
        anio_actual=anio_busqueda, # Pasamos el año para que el selector lo marque
        hoy_str=date.today().strftime("%Y-%m-%d"),
    )

@app.route("/alumnos/nuevo", methods=["POST"])
def nuevo_alumno():
    data = request.form.to_dict()
    # --- AGREGAR ESTO PARA EL CURSO Y AÑO ---
    curso_nro = data.pop("curso", "").strip()      # Sacamos el "3"
    seccion_letra = data.pop("seccion", "").strip() # Sacamos el "A"
    data["curso"] = f"{curso_nro}°{seccion_letra}" # Guardamos "3°A"
    
    # Capturamos el año del selector del modal y lo hacemos número
    data["anio_lectivo"] = int(data.get("anio_lectivo", 2025))
    # ----------------------------------------
    # 1) Fecha: del form viene como "fecha_nac"
    fecha_nac = (data.pop("fecha_nac", "") or "").strip()
    if fecha_nac:
        data["fecha_nacimiento"] = fecha_nac

    # 2) Responsable: "tutor" → "responsable"
    tutor = (data.pop("tutor", "") or "").strip()
    if tutor:
        data["responsable"] = tutor

    # 3) No guardamos edad_30jun
    data.pop("edad_30jun", None)

    # 4) RECURSANTES
    recursante_str = (data.pop("recursante", "") or "NO").strip().upper()
    data["recursante"] = (recursante_str == "SI")

    # 5) Normalizamos sexo
    sexo = (data.get("sexo") or "").strip().upper()
    if sexo:
        data["sexo"] = sexo

    # 6) Escuela de procedencia ya viene como "escuela_procedencia"
    escuela_procedencia = (data.get("escuela_procedencia") or "").strip()
    if escuela_procedencia:
        data["escuela_procedencia"] = escuela_procedencia
        # Fecha de ingreso: si no viene, usamos hoy
    if not data.get("fecha_ingreso"):
        data["fecha_ingreso"] = today().strftime("%Y-%m-%d")

    # Normalizamos campos de movimiento de salida (para altas normalmente quedan vacíos)
    motivo_salida = (data.get("motivo_salida") or "").strip()
    destino_salida = (data.get("destino_salida") or "").strip()
    data["motivo_salida"] = motivo_salida
    data["destino_salida"] = destino_salida

    # Un alumno nuevo NO debe tener fecha de salida
    data.pop("fecha_salida", None)

    # -------- Insertamos alumno --------
    res = COL_ALUMNOS.insert_one(data)  
    alumno_id = res.inserted_id

   
    # -------- Registramos movimiento inicial (ALTA real o MATRÍCULA) --------
    try:
          proc = (escuela_procedencia or "").strip()

          if _es_procedencia_externa(proc):
        # ✅ ALTA REAL (viene de otra escuela)
           _insert_movimiento_si_no_duplicado({
            "alumno_id": alumno_id,
            "tipo": "ALTA",
            "curso": (data.get("curso") or "").strip(),
            "apellido": (data.get("apellido") or "").strip(),
            "nombre": (data.get("nombre") or "").strip(),
            "dni": (data.get("dni") or "").strip(),
            "escuela_origen": proc,
            "escuela_destino": "E.P. N° 91",
            "fecha": datetime.utcnow(),
        })
          else:
        # 🟦 MATRÍCULA INICIAL (ya era de EP 91 o no se especifica procedencia)
           _insert_movimiento_si_no_duplicado({
            "alumno_id": alumno_id,
            "tipo": "MATRICULA",
            "curso": (data.get("curso") or "").strip(),
            "apellido": (data.get("apellido") or "").strip(),
            "nombre": (data.get("nombre") or "").strip(),
            "dni": (data.get("dni") or "").strip(),
            "fecha": datetime.utcnow(),
        })
    except Exception as e:
         print("Error registrando movimiento inicial:", e)
    return redirect(url_for("listar_alumnos"))    

@app.route("/alumnos/<id>/editar", methods=["POST"])
def editar_alumno(id):
    alumno = COL_ALUMNOS.find_one({"_id": ObjectId(id)})
    if not alumno:
        abort(404)

    updates_form = request.form.to_dict()

    set_fields = {}
    # --- AGREGAR ESTO PARA EL CURSO Y AÑO EN EDICIÓN ---
    curso_nro = updates_form.pop("curso", "").strip()
    seccion_letra = updates_form.pop("seccion", "").strip()
    if curso_nro and seccion_letra:
        set_fields["curso"] = f"{curso_nro}°{seccion_letra}"
    
    # Guardar el año lectivo si viene en el form
    if "anio_lectivo" in updates_form:
        set_fields["anio_lectivo"] = int(updates_form.get("anio_lectivo"))
    # --------------------------------------------------
    unset_fields = {}
    updates = {}

    # ----------------- DATOS BÁSICOS -----------------
    # fecha nac
    fecha_nac = (updates_form.pop("fecha_nac", "") or "").strip()
    if fecha_nac:
        set_fields["fecha_nacimiento"] = fecha_nac
    else:
        # si querés permitir vaciarlo:
        # unset_fields["fecha_nacimiento"] = ""
        pass

    # tutor/responsable
    tutor = (updates_form.pop("tutor", "") or "").strip()
    if tutor:
        set_fields["responsable"] = tutor
    else:
        # permitir vaciarlo si vienen espacios:
        if "tutor" in request.form:
            set_fields["responsable"] = ""

    # no guardamos edad calculada
    updates_form.pop("edad_30jun", None)

    recursante_str = (updates_form.pop("recursante", "") or "NO").strip().upper()
    set_fields["recursante"] = (recursante_str == "SI")

    sexo = (updates_form.get("sexo") or "").strip().upper()
    if sexo:
        set_fields["sexo"] = sexo

    # Copiamos el resto de campos comunes (limpiando strings)
    for k in (
        "apellido","nombre","dni","cuil","nacionalidad",
        "ocupacion","domicilio","localidad","telefono",
        "lugar_nacimiento","escuela_procedencia","observaciones"
    ):
        if k in updates_form:
            set_fields[k] = (updates_form.get(k) or "").strip()

    # ----------------- CURSO ACTUAL / DESTINO -----------------
    curso_actual = (alumno.get("curso") or "").strip()
    curso_form = (updates_form.get("curso") or "").strip()
    curso_destino = (updates_form.get("curso_destino") or "").strip()

    # ----------------- MOVIMIENTOS -----------------
    motivo_salida = (updates_form.get("motivo_salida") or "").strip().upper()
    destino_salida = (updates_form.get("destino_salida") or "").strip()
    fecha_salida_form = (updates_form.get("fecha_salida") or "").strip()

    # Normalizamos fecha (si no mandan, la ponemos hoy cuando corresponda)
    fecha_hoy = datetime.utcnow().strftime("%Y-%m-%d")
    if motivo_salida == "CAMBIO DE TURNO":
    # cambio de curso, alumno sigue activo
        set_fields["curso"] = curso_destino or curso_actual or curso_form
        set_fields["fecha_salida"] = None

    # histórico para pintarlo gris en el curso viejo
        set_fields["curso_origen"] = curso_actual
        set_fields["fecha_cambio_curso"] = fecha_salida_form or today().strftime("%Y-%m-%d")

    # ✅ no dejar “motivo_salida” persistente
        set_fields["motivo_salida"] = ""
        set_fields["destino_salida"] = ""
        set_fields["curso_destino"] = ""



    elif motivo_salida:
        # baja definitiva
        set_fields["curso"] = curso_form or curso_actual
        set_fields["fecha_salida"] = fecha_salida_form or fecha_hoy

        set_fields["motivo_salida"] = motivo_salida
        set_fields["destino_salida"] = destino_salida

        # si tenía histórico de cambio, lo limpiamos (no aplica más)
        unset_fields["curso_origen"] = ""
        unset_fields["fecha_cambio_curso"] = ""

    else:
        # ACTIVO (sin movimiento)
        set_fields["curso"] = curso_form or curso_actual
        set_fields["fecha_salida"] = None

        # 🔥 CLAVE: limpiar TODO rastro de histórico/movimiento en DB
        unset_fields["curso_origen"] = ""
        unset_fields["fecha_cambio_curso"] = ""
        unset_fields["motivo_salida"] = ""
        unset_fields["destino_salida"] = ""
        unset_fields["curso_destino"] = ""

    # ----------------- GUARDAR -----------------
    update_doc = {"$set": set_fields}
    if unset_fields:
        update_doc["$unset"] = unset_fields

    COL_ALUMNOS.update_one({"_id": ObjectId(id)}, update_doc)

    # ----------------- REGISTRAR MOVIMIENTO (si corresponde) -----------------
    try:
        # CAMBIO_TURNO
        if motivo_salida == "CAMBIO DE TURNO" and curso_destino and curso_destino != curso_actual:
            _insert_movimiento_si_no_duplicado({
                "alumno_id": ObjectId(id),
                "tipo": "CAMBIO_TURNO",
                "curso_origen": curso_actual,
                "curso_destino": curso_destino,
                "apellido": (alumno.get("apellido") or "").strip(),
                "nombre": (alumno.get("nombre") or "").strip(),
                "dni": (alumno.get("dni") or "").strip(),
                "fecha": datetime.utcnow(),
            })

        # BAJA (pase/egreso/otras)
        elif motivo_salida and motivo_salida != "CAMBIO DE TURNO":
            _insert_movimiento_si_no_duplicado({
                "alumno_id": ObjectId(id),
                "tipo": "BAJA",
                "motivo": motivo_salida,
                "curso": curso_actual,
                "apellido": (alumno.get("apellido") or "").strip(),
                "nombre": (alumno.get("nombre") or "").strip(),
                "dni": (alumno.get("dni") or "").strip(),
                "escuela_origen": "E.P. N° 91",
                "escuela_destino": destino_salida,
                "fecha": datetime.utcnow(),
            })

    except Exception as e: 
        print("Error registrando movimiento:", e)

    return redirect(url_for("listar_alumnos"))

@app.route("/alumnos/<id>/eliminar", methods=["POST"])
def eliminar_alumno(id):
    if not mongo_ping_ok():
        return render_template("db_down.html"), 503

    try:
        oid = ObjectId(id)
    except Exception:
        abort(404)

    # ✅ SOLO si viene hard=1 => borrado real
    hard_delete = (request.form.get("hard") or "").strip() == "1"

    # ✅ Para volver a la lista con los mismos filtros
    q = (request.form.get("q") or "").strip()
    curso = (request.form.get("curso") or "").strip()
    turno = (request.form.get("turno") or "").strip()
    historico = (request.form.get("historico") or "").strip()  # "1" o ""

    if hard_delete:
        # BORRADO REAL
        COL_ALUMNOS.delete_one({"_id": oid})

        # Limpieza relacionada
        try:
            COL_ASISTENCIA.delete_many({"alumno_id": oid})
        except Exception:
            pass

        try:
            COL_CALIFICACIONES.delete_many({"alumno_id": str(oid)})
        except Exception:
            pass

        flash("✅ Alumno eliminado definitivamente.", "success")
    else:
        # BAJA LÓGICA (histórico)
        COL_ALUMNOS.update_one(
            {"_id": oid},
            {"$set": {
                "activo": False,
                "fecha_salida": date.today().isoformat(),
                "sale_a": "ELIMINADO",
                "updated_at": datetime.utcnow()
            }}
        )
        flash("✅ Alumno pasado a histórico (baja lógica).", "success")

    # ✅ Volver a listar con filtros (sin depender del referrer)
    params = {}
    if q:
        params["q"] = q
    if curso:
        params["curso"] = curso
    if turno:
        params["turno"] = turno
    if historico:
        params["historico"] = historico

    url = url_for("listar_alumnos")
    if params:
        url = f"{url}?{urlencode(params)}"

    return redirect(url)

@app.post("/alumnos/eliminar_demos")
def eliminar_demos_alumnos():
    if not mongo_ping_ok(): 
        return render_template("db_down.html"), 503 
    
    if (request.form.get("confirm_demos") or "").strip().upper() != "SI":
        abort(403)

    patrones = ["demo", "prueba", "test", "xxxx", "asdf"]
    q_or = []
    for p in patrones:
        q_or.append({"apellido": {"$regex": p, "$options": "i"}})
        q_or.append({"nombre": {"$regex": p, "$options": "i"}})

    # Solo histórico (para que no borre reales activos por accidente)
    q = {"$and": [{"activo": {"$ne": True}}, {"$or": q_or}]}

    ids = [a["_id"] for a in COL_ALUMNOS.find(q, {"_id": 1})]

    if ids:
        COL_ALUMNOS.delete_many({"_id": {"$in": ids}})
        try:
            COL_ASISTENCIA.delete_many({"alumno_id": {"$in": ids}})
        except Exception:
            pass
        try:
            COL_CALIFICACIONES.delete_many({"alumno_id": {"$in": [str(i) for i in ids]}})
        except Exception:
            pass

    flash(f"✅ Eliminados demos: {len(ids)}", "success")
    return redirect(url_for("listar_alumnos", historico="1"))

@app.route("/alumnos/<id>/certificado")
def certificado_finalizacion(id):
    a = COL_ALUMNOS.find_one({"_id": ObjectId(id)})
    if not a:
        abort(404) 

    # Fecha de finalización configurable (.env), ej: CERT_FECHA_FIN=2025-12-22
    fecha_fin_str = os.getenv("CERT_FECHA_FIN", "2025-12-22")
    fecha_fin = datetime.strptime(fecha_fin_str, "%Y-%m-%d").date()

    alumno = to_json(a)

    dni = (alumno.get("dni") or "").strip()
    anexo = f"{dni}/069" if dni else "____/069"

    ctx = { 
        "alumno": alumno,
        "fecha_fin": fecha_fin,
        "fecha_fin_larga": fecha_larga_castellano(fecha_fin),
        "anexo": anexo,
    }
    return render_template("certificado_finalizacion.html", **ctx)

@app.get("/estudiantes/matricula_2026", endpoint="matricula_2026_view")

def matricula_2026_view():

    if not mongo_ping_ok():

        return render_template("db_down.html"), 503

    return render_template("matricula_2026.html")





@app.get("/estudiantes/matricula_2026/preview", endpoint="matricula_2026_preview")

def matricula_2026_preview():

    if not mongo_ping_ok():

        return jsonify({"ok": False, "error": "db_down"}), 503



    alumnos = list(COL_ALUMNOS.find({"activo": {"$ne": False}}))



    cambios = []

    sin_estado = []

    no_parseados = []

    sexto = []



    for a in alumnos:

        curso_actual = (a.get("curso") or "").strip()

        grado, sec = parse_curso(curso_actual)



        if grado is None:

            no_parseados.append(a)

            continue



        estado = (a.get("prom_rec_2026_2027") or "").strip().upper()



        if grado == 6:

            sexto.append(a)

            continue



        if estado not in ("PROM", "REC"):

            sin_estado.append(a)

            continue



        curso_nuevo = curso_actual if estado == "REC" else build_curso(grado + 1, sec)



        # Si querés ver también los REC aunque no cambien, dejalo igual:

        cambios.append({

            "id": str(a["_id"]),

            "apellido": a.get("apellido", ""),

            "nombre": a.get("nombre", ""),

            "dni": a.get("dni", ""),

            "curso_actual": curso_actual,

            "curso_nuevo": curso_nuevo,

            "estado": estado,

            "cambia": (curso_nuevo != curso_actual)

        })



    # Orden lindo: por curso actual, apellido, nombre

    def sort_key(x):

        g, s = parse_curso(x.get("curso_actual", ""))

        return (g or 99, s or "Z", x.get("apellido",""), x.get("nombre",""))



    cambios.sort(key=sort_key)



    return jsonify({

        "ok": True,

        "items": cambios,

        "stats": {

            "total": len(alumnos),

            "candidatos": len(cambios),

            "cambios_reales": sum(1 for x in cambios if x.get("cambia")),

            "sin_estado": len(sin_estado),

            "no_parseados": len(no_parseados),

            "sexto": len(sexto)

        }

    })





@app.post("/estudiantes/matricula_2026/aplicar", endpoint="matricula_2026_aplicar")

def matricula_2026_aplicar():

    if not mongo_ping_ok():

        return jsonify({"ok": False, "error": "db_down"}), 503



    data = request.get_json(silent=True) or {}

    if (data.get("confirm") or "").strip().upper() != "SI":

        return jsonify({"ok": False, "error": "confirm_required"}), 400



    alumnos = list(COL_ALUMNOS.find({"activo": {"$ne": False}}))



    updates = 0

    saltados = {"sin_estado": 0, "no_parseados": 0, "sexto": 0}



    for a in alumnos:

        curso_actual = (a.get("curso") or "").strip()

        grado, sec = parse_curso(curso_actual)



        if grado is None:

            saltados["no_parseados"] += 1

            continue



        if grado == 6:

            saltados["sexto"] += 1

            continue



        estado = (a.get("prom_rec_2026_2027") or "").strip().upper()

        if estado not in ("PROM", "REC"):

            saltados["sin_estado"] += 1

            continue



        curso_nuevo = curso_actual if estado == "REC" else build_curso(grado + 1, sec)



        if curso_nuevo != curso_actual:

            COL_ALUMNOS.update_one(

                {"_id": a["_id"]},

                {"$set": {

                    "curso": curso_nuevo,

                    "matricula_actualizada_2026": True,

                    "matricula_origen": curso_actual,

                    "updated_at": datetime.utcnow()

                }}

            )

            updates += 1



    return jsonify({"ok": True, "actualizados": updates, "saltados": saltados})
# ----------------- CALIFICACIONES APIs -----------------

@app.route("/api/asignaturas_escala", methods=["GET","POST"])
def api_asignaturas_escala():
    if request.method == "POST":
        data = request.get_json(silent=True) or {}
        asignatura = (data.get("asignatura") or "").strip()
        escala = (data.get("escala") or "").strip().lower()
        if escala not in ("conceptual","numerica") or not asignatura:
            return jsonify({"error":"Datos inválidos"}), 400
        COL_CFG_ASIGNATURAS.update_one(
            {"asignatura": asignatura},
            {"$set": {"asignatura": asignatura, "escala": escala}},
            upsert=True
        )
        return jsonify({"status":"ok"})
    cfg = { c.get("asignatura"): c.get("escala","conceptual")
            for c in COL_CFG_ASIGNATURAS.find({}) }
    return jsonify(cfg)

@app.route("/api/alumnos_por_curso")
def api_alumnos_por_curso():
    curso = (request.args.get("curso") or "").strip()
    if not curso:
        return jsonify([])

    alumnos = []
    q = {**filtro_activos(), "curso": {"$regex": f"^{curso}$", "$options": "i"}}

    for a in COL_ALUMNOS.find(q).sort([("apellido", 1), ("nombre", 1)]):
        aj = to_json(a)

        # ✅ AGREGADO: Datos de EOE para la ficha del alumno
        aj["causa_judicial"] = a.get("causa_judicial") or "-"
        aj["venc_judicial"] = a.get("venc_judicial") or ""
        aj["acompanante"] = a.get("acompanante") or "-"
        aj["horario_acomp"] = a.get("horario_acomp") or ""

        # Cálculo de edad
        if aj.get("fecha_nacimiento"):
            aj["edad_30jun"] = calcular_edad(aj["fecha_nacimiento"])

        # Manejo de autorizados a retirar
        autorizados_src = a.get("autorizados") or []
        if isinstance(autorizados_src, list):
            aj["autorizados_retirar"] = [
                {
                    "nombre": aut.get("nombre", ""),
                    "vinculo": aut.get("parentesco", ""),
                    "dni": aut.get("dni", ""),
                }
                for aut in autorizados_src
                if (aut.get("nombre") or "").strip()
            ]

        alumnos.append(aj)

    return jsonify(alumnos)

@app.route("/api/calificaciones", methods=["GET"])
def api_calificaciones_list():
    docente_id = (request.args.get("docente_id") or "").strip()
    asignatura = (request.args.get("asignatura") or "").strip()
    curso = (request.args.get("curso") or "").strip()
    trimestre_raw = (request.args.get("trimestre") or "").strip()
    anio_raw = (request.args.get("anio") or "").strip()

    # ✅ Trimestre: "1","2","3" o "all" o vacío
    trimestre = trimestre_raw.lower()

    q = {}

    # ✅ IDs como STRING (Opción 1)
    if docente_id:
        q["docente_id"] = docente_id
    if asignatura:
        q["asignatura"] = asignatura

    # ✅ Año: si viene, lo usamos; si no viene, default al año actual
    try:
        q["anio"] = int(anio_raw) if anio_raw else datetime.now().year
    except ValueError:
        q["anio"] = datetime.now().year

    # ✅ Trimestre: solo filtrar si es 1/2/3
    if trimestre and trimestre != "all":
        try:
            tri_int = int(trimestre)
            if tri_int in (1, 2, 3):
                q["trimestre"] = tri_int
        except ValueError:
            pass

    # ✅ Curso: NO filtres por q["curso"], filtrá por alumno_id IN ids
    if curso:
        alumnos_ids = [
            str(a["_id"])
            for a in COL_ALUMNOS.find(
                {**filtro_activos(), "curso": {"$regex": f"^{curso}$", "$options": "i"}},
                {"_id": 1}
            )
        ]

        # si no hay alumnos en ese curso → no hay calificaciones para devolver
        if not alumnos_ids:
            return jsonify([])

        q["alumno_id"] = {"$in": alumnos_ids}

    registros = [to_json(c) for c in COL_CALIFICACIONES.find(q)]
    return jsonify(registros)


@app.route("/api/calificaciones", methods=["POST"])
def api_calificaciones_upsert():
    data = request.get_json(silent=True) or {}

    alumno_id  = (data.get("alumno_id") or "").strip()
    docente_id = (data.get("docente_id") or "").strip()
    asignatura = (data.get("asignatura") or "").strip()
    curso      = (data.get("curso") or "").strip()   # snapshot (opcional)
    escala     = (data.get("escala") or "").strip().lower()
    valor      = (data.get("valor") or "").strip()
    observaciones = (data.get("observaciones") or "").strip()

    # año (si no viene, usamos actual)
    try:
        anio = int(data.get("anio") or datetime.now().year)
    except Exception:
        anio = datetime.now().year

    # trimestre
    try:
        trimestre = int(data.get("trimestre") or 0)
    except Exception:
        trimestre = 0

    if not all([alumno_id, docente_id, asignatura, trimestre, escala, valor]):
        return jsonify({"error": "Campos obligatorios faltantes"}), 400

    if trimestre not in (1, 2, 3):
        return jsonify({"error": "Trimestre inválido"}), 400

    if escala not in ("conceptual", "numerica"):
        return jsonify({"error": "Escala inválida"}), 400

    if escala == "numerica":
        try:
            n = float(valor.replace(",", "."))
        except Exception:
            return jsonify({"error": "Nota numérica inválida"}), 400
        if n < 1 or n > 10:
            return jsonify({"error": "Nota fuera de rango (1 a 10)"}), 400
        valor = str(n).rstrip("0").rstrip(".")

    # ✅ KEY: ahora incluye anio (para que el GET por año encuentre)
    key = {
        "alumno_id": alumno_id,
        "docente_id": docente_id,
        "asignatura": asignatura,
        "trimestre": trimestre,
        "anio": anio,
    }

    COL_CALIFICACIONES.update_one(
        key,
        {"$set": {
            "escala": escala,
            "valor": valor,
            "observaciones": observaciones,
            "curso": curso,
            "anio": anio,
            "updated_at": datetime.utcnow()
        }, "$setOnInsert": {"created_at": datetime.utcnow()}},
        upsert=True
    )

    cal = COL_CALIFICACIONES.find_one(key)
    return jsonify(to_json(cal))


@app.route("/api/calificaciones/<id>", methods=["DELETE"])
def api_calificaciones_delete(id):
    COL_CALIFICACIONES.delete_one({"_id": ObjectId(id)})
    return jsonify({"status":"ok"})

def obtener_alerta_ausentismo(alumno_id, mes, anio):
    asistencia = COL_ASISTENCIAS.find_one({"alumno_id": ObjectId(alumno_id), "month": int(mes), "year": int(anio)})
    if not asistencia:
        return None, 0

    dias = asistencia.get("dias", {})
    valores = list(dias.values()) # Ej: ['P', 'A', 'A', 'A', 'P']
    
    total_inasistencias = valores.count('A')
    
    # Lógica de seguidas
    max_seguidas = 0
    contador = 0
    for v in valores:
        if v == 'A':
            contador += 1
            max_seguidas = max(max_seguidas, contador)
        else:
            contador = 0
            
    if max_seguidas >= 3:
        return "3 o más seguidas", total_inasistencias
    if total_inasistencias >= 5:
        return "5 o más alternadas", total_inasistencias
        
    return None, total_inasistencias

@app.route('/eoe/ausentismo')
def eoe_ausentismo():
    hoy = datetime.now()
    mes_actual = hoy.month
    anio_actual = hoy.year

    curso_sel = request.args.get('curso', '')

    # NUEVO: año seleccionado
    anio_sel = request.args.get('anio', str(anio_actual))
    try:
        anio_sel_int = int(anio_sel)
    except Exception:
        anio_sel_int = anio_actual

    # para el selector de años (últimos 6)
    anios = list(range(anio_actual, anio_actual - 6, -1))

    cursos = sorted(COL_ALUMNOS.distinct("curso"))

    query = {"historico": {"$ne": True}}
    if curso_sel:
        query["curso"] = curso_sel

    alumnos_raw = list(COL_ALUMNOS.find(query).sort([("apellido", 1), ("nombre", 1)]))
    alumnos_con_datos = []

    for alu in alumnos_raw:
        alerta, total_faltas = obtener_alerta_ausentismo(str(alu["_id"]), mes_actual, anio_sel_int)
        alu["total_faltas"] = total_faltas
        alu["alerta_texto"] = alerta if alerta else "Sin alerta"
        alumnos_con_datos.append(alu)

    return render_template(
        "ausentismo.html",
        alumnos=alumnos_con_datos,
        cursos=cursos, 
        curso_sel=curso_sel,
        anios=anios,                 # NUEVO
        anio_sel=anio_sel_int,       # NUEVO
        hoy=hoy.strftime('%d/%m/%Y'),
        hoy_mes=mes_actual,
        hoy_anio=anio_sel_int        # IMPORTANTE: usar el seleccionado
    )

@app.route('/eoe/judiciales')
def eoe_judiciales():
    curso_sel = request.args.get('curso', '')
    cursos = sorted(COL_ALUMNOS.distinct("curso"))

    query = {"historico": {"$ne": True}}
    if curso_sel:
        query["curso"] = curso_sel

    alumnos = list(COL_ALUMNOS.find(query).sort([("apellido", 1), ("nombre", 1)]))

    hoy = date.today()
    hoy_iso = hoy.strftime('%Y-%m-%d')

    # ⚠️ días antes para avisar "por vencer"
    UMBRAL_DIAS = 15

    for alu in alumnos:
        alu["jud_venc_estado"] = ""
        alu["jud_dias_rest"] = None

        venc_str = (alu.get("venc_judicial") or "").strip()
        if not venc_str:
            continue

        try:
            venc_date = datetime.strptime(venc_str, "%Y-%m-%d").date()
        except ValueError:
            continue

        dias = (venc_date - hoy).days
        alu["jud_dias_rest"] = dias

        if dias < 0:
            alu["jud_venc_estado"] = "vencida"
        elif dias <= UMBRAL_DIAS:
            alu["jud_venc_estado"] = "por_vencer"

    return render_template(
        "judiciales_acompañantes.html",
        alumnos=alumnos,
        cursos=cursos,
        curso_sel=curso_sel,
        hoy_iso=hoy_iso
    )


@app.route("/api/eoe/actualizar_judicial", methods=["POST"])
def actualizar_judicial():
    data = request.json
    id_alumno = data.get("id")
    campo = data.get("campo") # ej: 'causa_judicial'
    valor = data.get("valor")
    
    COL_ALUMNOS.update_one(
        {"_id": ObjectId(id_alumno)},
        {"$set": {campo: valor}}
    )
    return jsonify({"status": "ok"})
# ==============================
# ESTUDIANTES · MERCADERÍA / LISTAS / PROM-REC
# ==============================

@app.get("/estudiantes/entrega_mercaderia", endpoint="entrega_mercaderia")
def entrega_mercaderia_view():
    if not mongo_ping_ok():
        return render_template("db_down.html"), 503

    curso_filtrado = (request.args.get("curso") or "").strip()

    alumnos_q = {"activo": {"$ne": False}}
    if curso_filtrado:
        alumnos_q["curso"] = curso_filtrado

    alumnos = list(
        COL_ALUMNOS.find(alumnos_q).sort([("curso", 1), ("apellido", 1), ("nombre", 1)])
    )

    periodos = periodos_mar2026_feb2027()
    periodos_labels = [{"key": p, "label": label_periodo(p)} for p in periodos]

    # Pre-carga entregas existentes
    entregas_map = {}
    q_ent = {"periodo": {"$in": periodos}}
    for e in COL_MERCADERIA.find(q_ent, {"alumno_id": 1, "periodo": 1, "recibido": 1}):
        aid = str(e.get("alumno_id"))
        entregas_map.setdefault(aid, {})[e["periodo"]] = bool(e.get("recibido"))

    grupos = {}
    for a in alumnos:
        curso = (a.get("curso") or "").strip()
        grupos.setdefault(curso, []).append(a)

    # Para el dropdown: siempre mostrar todos los cursos existentes (aunque estés filtrando)
    # Si preferís que muestre solo los cursos del filtro, avisame.
    todos = list(
        COL_ALUMNOS.find({"activo": {"$ne": False}}, {"curso": 1}).sort([("curso", 1)])
    )
    cursos_unicos = sorted({(x.get("curso") or "").strip() for x in todos if (x.get("curso") or "").strip()}, key=ordenar_curso_key)

    cursos_ordenados = sorted(grupos.keys(), key=ordenar_curso_key)

    return render_template(
        "entrega_mercaderia.html",
        grupos=grupos,
        cursos_ordenados=cursos_ordenados,
        cursos_unicos=cursos_unicos,
        periodos=periodos_labels,
        entregas_map=entregas_map,
        curso_filtrado=curso_filtrado
    )


@app.post("/estudiantes/entrega_mercaderia/toggle", endpoint="entrega_mercaderia_toggle")
def entrega_mercaderia_toggle():
    if not mongo_ping_ok():
        return jsonify({"ok": False, "error": "db_down"}), 503

    data = request.get_json(silent=True) or {}
    alumno_id = (data.get("alumno_id") or "").strip()
    periodo = (data.get("periodo") or "").strip()
    recibido = bool(data.get("recibido"))

    if not alumno_id or not periodo:
        return jsonify({"ok": False, "error": "missing"}), 400

    try:
        oid = ObjectId(alumno_id)
    except Exception:
        return jsonify({"ok": False, "error": "bad_id"}), 400

    if not COL_ALUMNOS.find_one({"_id": oid}, {"_id": 1}):
        return jsonify({"ok": False, "error": "not_found"}), 404

    COL_MERCADERIA.update_one(
        {"alumno_id": oid, "periodo": periodo},
        {"$set": {"recibido": recibido, "updated_at": datetime.utcnow()}},
        upsert=True
    )

    return jsonify({"ok": True})


@app.get("/estudiantes/listas", endpoint="listas_estudiantes")
def listas_estudiantes_view():
    if not mongo_ping_ok():
        return render_template("db_down.html"), 503

    curso_filtrado = (request.args.get("curso") or "").strip()

    q = {"activo": {"$ne": False}}
    if curso_filtrado:
        q["curso"] = curso_filtrado

    alumnos = list(
        COL_ALUMNOS.find(q).sort([("curso", 1), ("apellido", 1), ("nombre", 1)])
    )

    grupos = {}
    for a in alumnos:
        curso = (a.get("curso") or "").strip()
        grupos.setdefault(curso, []).append(a)

    todos = list(
        COL_ALUMNOS.find({"activo": {"$ne": False}}, {"curso": 1}).sort([("curso", 1)])
    )
    cursos_unicos = sorted({(x.get("curso") or "").strip() for x in todos if (x.get("curso") or "").strip()}, key=ordenar_curso_key)

    cursos_ordenados = sorted(grupos.keys(), key=ordenar_curso_key)

    return render_template(
        "listas.html",
        grupos=grupos,
        cursos_ordenados=cursos_ordenados,
        cursos_unicos=cursos_unicos,
        curso_filtrado=curso_filtrado
    )


@app.get("/estudiantes/prom_rec", endpoint="prom_rec")
def prom_rec_view():
    if not mongo_ping_ok():
        return render_template("db_down.html"), 503

    curso_filtrado = (request.args.get("curso") or "").strip()

    q = {"activo": {"$ne": False}}
    if curso_filtrado:
        q["curso"] = curso_filtrado

    alumnos = list(
        COL_ALUMNOS.find(q).sort([("curso", 1), ("apellido", 1), ("nombre", 1)])
    )

    grupos = {}
    for a in alumnos:
        curso = (a.get("curso") or "").strip()
        grupos.setdefault(curso, []).append(a)

    todos = list(
        COL_ALUMNOS.find({"activo": {"$ne": False}}, {"curso": 1}).sort([("curso", 1)])
    )
    cursos_unicos = sorted({(x.get("curso") or "").strip() for x in todos if (x.get("curso") or "").strip()}, key=ordenar_curso_key)

    cursos_ordenados = sorted(grupos.keys(), key=ordenar_curso_key)

    return render_template(
        "prom_rec.html",
        grupos=grupos,
        cursos_ordenados=cursos_ordenados,
        cursos_unicos=cursos_unicos,
        curso_filtrado=curso_filtrado
    )


@app.post("/estudiantes/prom_rec/guardar", endpoint="prom_rec_guardar")
def prom_rec_guardar():
    if not mongo_ping_ok():
        return jsonify({"ok": False, "error": "db_down"}), 503

    data = request.get_json(silent=True) or {}
    alumno_id = (data.get("alumno_id") or "").strip()
    valor = (data.get("valor") or "").strip().upper()

    if not alumno_id:
        return jsonify({"ok": False, "error": "missing"}), 400

    if valor not in ("PROM", "REC"):
        return jsonify({"ok": False, "error": "bad_value"}), 400

    try:
        oid = ObjectId(alumno_id)
    except Exception:
        return jsonify({"ok": False, "error": "bad_id"}), 400

    res = COL_ALUMNOS.update_one(
        {"_id": oid},
        {"$set": {"prom_rec_2026_2027": valor, "updated_at": datetime.utcnow()}}
    )

    if res.matched_count == 0:
        return jsonify({"ok": False, "error": "not_found"}), 404

    return jsonify({"ok": True})

# Pequeña ruta para seleccionar el curso y mes por 

@app.route("/asistencia", methods=["GET"])
def seleccionar_asistencia():
    """Redirige al mes y curso por defecto."""
    COL_ALUMNOS = app.mongo.alumnos 
    
    today_date = date.today()
    
    # Obtener el primer curso disponible para redirigir
    cursos_disponibles = COL_ALUMNOS.distinct("curso", filtro_activos())
    primer_curso = sorted(cursos_disponibles)[0] if cursos_disponibles else "1°A"
    
    return redirect(url_for(
        "asistencia_mensual", 
        curso=primer_curso, 
        year=today_date.year, 
        month=today_date.month
    ))

@app.route('/asistencia/<curso>/<int:year>/<int:month>', methods=['GET', 'POST'])
def asistencia_mensual(curso, year, month):
    """
    Maneja la visualización y guardado (GET y POST) de la asistencia mensual.
    """

    # Cursos disponibles para el selector
    cursos = sorted([c for c in COL_ALUMNOS.distinct("curso", filtro_activos()) if c])

    # Obtener días hábiles
    try:
        dias_habil_registrados = get_dias_habiles(year, month)

        if not dias_habil_registrados:
            print(f"DEBUG ASISTENCIA: get_dias_habiles({year}, {month}) devolvió lista vacía.")
        else:
            print(
                f"DEBUG ASISTENCIA: Días hábiles encontrados: {len(dias_habil_registrados)}. "
                f"Primer día: {dias_habil_registrados[0].isoformat()}. "
                f"Último día: {dias_habil_registrados[-1].isoformat()}"
            )

    except ValueError:
        abort(400, description="Fecha inválida.")

    # Fechas para navegación
    current_date = date(year, month, 1)
    prev_month_date = current_date - relativedelta(months=1)
    next_month_date = current_date + relativedelta(months=1)

    # Mes en castellano
    meses_es = [
        "enero", "febrero", "marzo", "abril", "mayo", "junio",
        "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"
    ]
    mes_actual = f"{meses_es[current_date.month - 1].capitalize()} de {current_date.year}"

    # ----------------------------------------------------------------------
    #                          PROCESAR POST
    # ----------------------------------------------------------------------
    if request.method == 'POST':

        for key, value in request.form.items():
            if not key.startswith('asistencia_'):
                continue

            try:
                # asistencia_<alumno_id>_<YYYY-MM-DD>
                parts = key.split('_')
                alumno_id_str = parts[1]
                asistencia_date_iso = parts[2]
                estado = value.upper().strip()

                query = {
                    'alumno_id': ObjectId(alumno_id_str),
                    'fecha': asistencia_date_iso,
                    
                }

                if estado in ['P', 'A', 'X']:
                    update = {'$set': {'estado': estado, "curso": curso}}
                    COL_ASISTENCIA.update_one(query, update, upsert=True)
                elif estado == '':
                    COL_ASISTENCIA.delete_one(query)

            except Exception as e:
                print(f"[ERROR ASISTENCIA] clave '{key}' valor '{value}': {e}")
                continue

        # Post-Redirect-Get
        return redirect(url_for('asistencia_mensual', curso=curso, year=year, month=month))

    # ----------------------------------------------------------------------
    #                          PROCESAR GET
    # ----------------------------------------------------------------------

    # Alumnos ordenados por apellido
    alumnos = list(COL_ALUMNOS.find({**filtro_activos(), "curso": curso}).sort("apellido", 1))

    # Rango de fechas del mes
    start_date = date(year, month, 1)
    last_day_of_month = date(year, month, 1) + relativedelta(months=1) - timedelta(days=1)

    start_date_iso = start_date.isoformat()
    end_date_iso = last_day_of_month.isoformat()

    # Obtener asistencias del mes (lista, no cursor)
    alumno_ids = [a["_id"] for a in alumnos]  # alumnos ya es la lista del curso actual

    asistencias_mes = list(COL_ASISTENCIA.find({
    'alumno_id': {'$in': alumno_ids},
    'fecha': {'$gte': start_date_iso, '$lte': end_date_iso}
}))

    # Mapeo: alumno → {fecha → estado}
    asistencia_map = {}
    for reg in asistencias_mes:
        try:
            fecha_iso = reg['fecha']
            alumno_id = str(reg['alumno_id'])

            if alumno_id not in asistencia_map:
                asistencia_map[alumno_id] = {}

            asistencia_map[alumno_id][fecha_iso] = reg.get('estado', '')

        except Exception as e:
            print(f"ERROR MAPEO ASISTENCIA: {e}")
            continue

    # Unir alumnos con sus asistencias
    alumnos_con_asistencia = []
    for alumno in alumnos:
        alumno_id = str(alumno['_id'])
        alumno['asistencia_mensual'] = asistencia_map.get(alumno_id, {})
        alumnos_con_asistencia.append(alumno)

    # ------------------------------------------------------------------
    #                     RESUMEN SEMANAL (MES ACTUAL)
    # ------------------------------------------------------------------
    resumen_semanal = {}   # {alumno_id: {semana: {"P":x,"A":y,"D":z}}}
    max_semana = 0

    for reg in asistencias_mes:
        try:
            estado = reg.get('estado', '') 
            if estado not in ('P', 'A'):
                continue

            fecha_iso = reg['fecha']
            fecha = date.fromisoformat(fecha_iso)
            semana = (fecha.day - 1) // 7 + 1  # Semana 1..5

            aid = str(reg['alumno_id'])
            semanas_map = resumen_semanal.setdefault(aid, {})
            info = semanas_map.setdefault(semana, {'P': 0, 'A': 0, 'D': 0})

            info[estado] += 1
            info['D'] += 1

            if semana > max_semana:
                max_semana = semana

        except Exception as e:
            print(f"ERROR RESUMEN SEMANAL: {e}")  
            continue

    # Si no hubo asistencias cargadas, igual determinamos cuántas semanas tiene el mes
    if max_semana == 0 and dias_habil_registrados:
        max_semana = max((d.day - 1) // 7 + 1 for d in dias_habil_registrados)
    if max_semana == 0:
        max_semana = 4  # valor por defecto

    # ------------------------------------------------------------------
    #              RESÚMENES TRIMESTRAL Y ANUAL POR ALUMNO
    # ------------------------------------------------------------------

    # Trimestre actual (1: meses 1-3, 2: 4-6, 3: 7-9, 4: 10-12)
    trimestre_idx = (month - 1) // 3          # 0,1,2,3
    tri_start_month = trimestre_idx * 3 + 1   # 1,4,7,10
    tri_end_month = tri_start_month + 2       # 3,6,9,12

    tri_start_date = date(year, tri_start_month, 1)
    tri_end_date = date(year, tri_end_month, 1) + relativedelta(months=1) - timedelta(days=1)

    year_start_date = date(year, 1, 1)
    year_end_date = date(year, 12, 31)

    # Asistencias del trimestre
    tri_asist = COL_ASISTENCIA.find({
    'alumno_id': {'$in': alumno_ids},
    'fecha': {'$gte': tri_start_date.isoformat(), '$lte': tri_end_date.isoformat()}
})

    year_asist = COL_ASISTENCIA.find({ 
    'alumno_id': {'$in': alumno_ids},
    'fecha': {'$gte': year_start_date.isoformat(), '$lte': year_end_date.isoformat()}
})


    resumen_trimestre = {}  # {alumno_id: {"P":x, "A":y, "D":z}}
    for reg in tri_asist:
        aid = str(reg['alumno_id'])
        estado = reg.get('estado', '')
        if estado not in ('P', 'A'):
            continue
        info = resumen_trimestre.setdefault(aid, {'P': 0, 'A': 0, 'D': 0})
        info[estado] += 1
        info['D'] += 1

    resumen_anual = {}      # {alumno_id: {"P":x, "A":y, "D":z}}
    for reg in year_asist:
        aid = str(reg['alumno_id'])
        estado = reg.get('estado', '')
        if estado not in ('P', 'A'):
            continue
        info = resumen_anual.setdefault(aid, {'P': 0, 'A': 0, 'D': 0})
        info[estado] += 1
        info['D'] += 1

    numero_trimestre = trimestre_idx + 1

    # ----------------------------------------------------------------------
    #                           RENDER TEMPLATE
    # ----------------------------------------------------------------------
    return render_template(
        'asistencia_mensual.html',
        curso=curso,
        cursos=cursos,
        alumnos=alumnos_con_asistencia,
        mes_actual=mes_actual,
        dias_habiles=dias_habil_registrados,
        current_year=year,
        current_month=month,
        prev_year=prev_month_date.year,
        prev_month=prev_month_date.month,
        next_year=next_month_date.year,
        next_month=next_month_date.month,
        today_func=today(),
        resumen_semanal=resumen_semanal,
        max_semana=max_semana,
        resumen_trimestre=resumen_trimestre,
        resumen_anual=resumen_anual,
        numero_trimestre=numero_trimestre,
    )

@app.route("/alumnos/<id>/mapa")
def mapa_alumno(id):
    a = COL_ALUMNOS.find_one({"_id": ObjectId(id)})
    if not a:
        abort(404)

    domicilio = (a.get("domicilio") or "").strip()
    localidad = (a.get("localidad") or "Isidro Casanova").strip()
    provincia = (a.get("provincia") or "Buenos Aires").strip()

    if not domicilio:
        # Sin domicilio no tiene sentido el mapa
        abort(404)

    destino = f"{domicilio}, {localidad}, {provincia}, Argentina"
    url = (
        "https://www.google.com/maps/dir/?api=1"
        f"&origin={quote('Tomás Edison 2164, Isidro Casanova, Buenos Aires, Argentina')}"
        f"&destination={quote(destino)}"
    )
    return redirect(url)

# ----------------- CALIFICACIONES (vista principal) -----------------

@app.route("/calificaciones")
def calificaciones_gestion():
    """
    Redirige a la vista única de gestión de calificaciones.
    Así evitamos tener dos rutas distintas con datos distintos.
    """
    return redirect(url_for("calificaciones_gestionar"))


@app.route("/calificaciones/gestionar")
def calificaciones_gestionar():
    # 1. Obtenemos listas básicas
    docentes = list(COL_DOCENTES.find().sort([("apellido", 1), ("nombre", 1)]))
    cursos = sorted(COL_ALUMNOS.distinct("curso"))
    
    # 2. Definimos las asignaturas (asegurando que coincidan con tu lista)
    asignaturas = [
        "Prácticas del Lenguaje",
        "Matemática",
        "Ciencias Sociales",
        "Ciencias Naturales",
        "Inglés",
        "Educación Plástica",
        "Educación Musical",
        "Educación Física",
        "Quinta Hora"
    ]

    # 3. Traemos las escalas guardadas para que el JS sepa cuál usar
    cfg_asignaturas = {}
    for doc in COL_CONFIG.find({"tipo": "asignatura_escala"}):
        cfg_asignaturas[doc["asignatura"]] = doc["escala"]

    # 4. Fecha de hoy para comparar vencimientos en la ficha si fuera necesario
    hoy_iso = datetime.now().strftime('%Y-%m-%d')

    return render_template(
        "calificaciones_gestion.html",
        docentes=docentes,
        cursos=cursos,
        asignaturas=asignaturas,
        cfg_asignaturas=cfg_asignaturas,
        hoy_iso=hoy_iso # Agregamos esto por seguridad
    )
#  Ruta para el Parte Diario

@app.route("/parte_diario", methods=["GET"])
def parte_diario():
    # Obtener mes y año de la URL o usar el actual
    hoy = today()
    try:
        mes = int(request.args.get("mes", hoy.month))
        anio = int(request.args.get("anio", hoy.year))
    except (ValueError, TypeError):
        # Fallback a la fecha actual si los parámetros son inválidos
        mes = hoy.month
        anio = hoy.year

    datos = calcular_matricula_mensual(mes, anio) 

    # Preparar el mes anterior y posterior para la navegación (flechitas)
    fecha_actual = datetime(anio, mes, 1)
    mes_anterior = fecha_actual - relativedelta(months=1)
    mes_posterior = fecha_actual + relativedelta(months=1)
    
    # Asignar URLs de navegación
    datos["mes_anterior_url"] = url_for("parte_diario", mes=mes_anterior.month, anio=mes_anterior.year)
    datos["mes_posterior_url"] = url_for("parte_diario", mes=mes_posterior.month, anio=mes_posterior.year)

    return render_template("parte_diario.html", **datos)

@app.route("/resumen/edades")
def resumen_edades():
    """Cuadros-resumen por curso: edades, sexo, nacionalidades y recursantes.

    Se calcula todo dinámicamente a partir de la colección de alumnos
    usando como referencia el 30/06 del año configurado en EDADES_REF_ANIO
    (o el año actual por defecto).
    """
    ref_year = int(os.getenv("EDADES_REF_ANIO", datetime.now().year))
    ref_fecha = date(ref_year, 6, 30)

    resumen = defaultdict(
        lambda: {
            "sexo": {"M": 0, "F": 0, "X": 0, "total": 0},
            "edades": defaultdict(lambda: {"M": 0, "F": 0, "X": 0, "total": 0}),
            "nacionalidades": defaultdict(lambda: {"M": 0, "F": 0, "X": 0, "total": 0}),
            "recursantes": {"M": 0, "F": 0, "X": 0, "total": 0},
        }
    )

    for a in COL_ALUMNOS.find(filtro_activos()):

        curso = (a.get("curso") or "").strip()
        if not curso:
            continue

        # Normalizar sexo
        sexo_raw = (a.get("sexo") or "").strip().upper()
        if sexo_raw.startswith("M"):
            sexo = "M"
        elif sexo_raw.startswith("F"):
            sexo = "F"
        else:
            sexo = "X"

        r = resumen[curso]

        # Matrícula por sexo
        r["sexo"][sexo] += 1
        r["sexo"]["total"] += 1

        # Edad al 30/06
        fn = a.get("fecha_nacimiento")
        edad = calcular_edad(fn, referencia=ref_fecha) if fn else None
        if edad is not None:
            e_bucket = r["edades"][edad]
            e_bucket[sexo] += 1
            e_bucket["total"] += 1

        # Nacionalidad
                # Nacionalidad (normalizada)
        raw_nac = (a.get("nacionalidad") or "").strip()
        if not raw_nac:
            nac = "SIN DATO"
        else:
            up = raw_nac.upper().replace(".", "").strip()
            if up in ("ARG", "ARGENTINA", "ARGENTINO", "ARGENTINOS", "ARGENTINAS"):
                nac = "Argentina"
            else:
                nac = raw_nac  # se respeta el texto tal cual

        n_bucket = r["nacionalidades"][nac]
        n_bucket[sexo] += 1
        n_bucket["total"] += 1


        # Recursantes
        if a.get("recursante"):
            r["recursantes"][sexo] += 1
            r["recursantes"]["total"] += 1

    cursos = sorted(resumen.keys(), key=_orden_curso)

    return render_template(
        "resumen_edades.html",
        resumen=resumen,
        cursos=cursos,
        ref_fecha=ref_fecha,
    )
@app.route("/resumen/nacionalidades")
def resumen_nacionalidades():
    """
    Por curso, cuenta alumnos por nacionalidad (y sexo).
    """
    alumnos = list(COL_ALUMNOS.find(filtro_activos()))

    # data[curso][nacionalidad][sexo] = count
    data = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))
    cursos_set = set()
    nacs_set = set()

    for a in alumnos:
        curso = (a.get("curso") or "").strip()
        if not curso:
            continue
        cursos_set.add(curso)
        raw = (a.get("nacionalidad") or "").strip()
        up = raw.upper().replace(".", "").strip()

        if not up:
            nac = "SIN DATO"
        elif up in ("ARG", "ARGENTINA", "ARGENTINO", "ARGENTINOS", "ARGENTINAS"):
            nac = "ARGENTINA"
        else:
            nac = up

        nacs_set.add(nac)

        sexo = (a.get("sexo") or "").strip().upper()
        if sexo not in ("M", "F"):
            sexo = "X"

        data[curso][nac][sexo] += 1

    cursos = sorted(cursos_set)
    nacs = sorted(nacs_set)

    return render_template(
        "resumen_nacionalidades.html",
        data=data,
        cursos=cursos,
        nacs=nacs,
    )

@app.route("/resumen/inasistencias")
def resumen_inasistencias():
    anio_param = (request.args.get("anio") or "").strip()
    try:
        anio = int(anio_param) if anio_param else date.today().year
    except ValueError:
        anio = date.today().year

    # feriados + suspensiones para estadística
    no_laborables = _no_laborables_set(anio)

    docentes = list(COL_DOCENTES.find({}))
    if not docentes:
        return render_template(
            "resumen_inasistencias.html",
            anio=anio, meses=[], dias=[], resumen_por_docente=[],
            nota_dias_base="Días base: suma institucional de días programados de todos los docentes."
        )

    desde_iso = date(anio, 1, 1).isoformat()
    hasta_iso = date(anio, 12, 31).isoformat()
    inas = list(COL_INASISTENCIAS.find({"fecha": {"$gte": desde_iso, "$lte": hasta_iso}}))

    faltas_doc_mes = defaultdict(int)      # (docente_id_str, mes) -> cant
    faltas_por_fecha = defaultdict(int)    # "YYYY-MM-DD" -> cant

    for ins in inas:
        f = _parse_date(ins.get("fecha"))
        if not f:
            continue
        did = str(ins.get("docente_id") or "")
        faltas_doc_mes[(did, f.month)] += 1
        faltas_por_fecha[f.isoformat()] += 1

    # -------- Mensual institucional --------
    meses = []
    for mes in range(1, 13):
        dias_base_institucional = 0
        faltas_total_mes = 0

        for d in docentes:
            did = str(d.get("_id"))
            dias_base_institucional += dias_base_mes_para_docente(d, anio, mes, no_laborables=no_laborables)
            faltas_total_mes += faltas_doc_mes.get((did, mes), 0)

        pct = 0.0
        if dias_base_institucional > 0:
            pct = (faltas_total_mes / dias_base_institucional) * 100
            pct = min(round(pct, 1), 100.0)

        meses.append({
            "mes": mes,
            "mes_nombre": MESES_MAYUS.get(mes, str(mes)),
            "faltas": faltas_total_mes,
            "dias_base": dias_base_institucional,   # OJO: institucional
            "porcentaje": pct,
        })

    # -------- Ranking anual por docente (porcentaje real del docente) --------
    resumen_por_docente = []
    for d in docentes:
        did = str(d.get("_id"))

        faltas_anual = 0
        dias_prog_anual = 0

        for mes in range(1, 13):
            faltas_anual += faltas_doc_mes.get((did, mes), 0)
            dias_prog_anual += dias_base_mes_para_docente(d, anio, mes, no_laborables=no_laborables)

        pct = 0.0
        if dias_prog_anual > 0:
            pct = (faltas_anual / dias_prog_anual) * 100
            pct = min(round(pct, 1), 100.0)

        resumen_por_docente.append({
            "apellido": d.get("apellido", ""),
            "nombre": d.get("nombre", ""),
            "cargo": d.get("cargo", ""),
            "faltas": faltas_anual,
            "dias_base": dias_prog_anual,   # del docente
            "porcentaje": pct,
        })

    resumen_por_docente.sort(key=lambda x: x["porcentaje"], reverse=True)

    # -------- Diario institucional (opcional para gráfico diario) --------
    dias = []
    for mes in range(1, 13):
        for f in get_dias_habiles(anio, mes, no_laborables=no_laborables):
            esperados = 0
            for doc in docentes:
                if docente_esperado_en_fecha(doc, f, no_laborables=no_laborables):
                    esperados += 1

            faltas_dia = faltas_por_fecha.get(f.isoformat(), 0)

            pct_dia = 0.0
            if esperados > 0:
                pct_dia = (faltas_dia / esperados) * 100
                pct_dia = min(round(pct_dia, 1), 100.0)

            dias.append({
                "fecha": f.isoformat(),
                "faltas": faltas_dia,
                "esperados": esperados,
                "porcentaje": pct_dia,
            })

    return render_template(
        "resumen_inasistencias.html",
        anio=anio,
        meses=meses,
        dias=dias,
        resumen_por_docente=resumen_por_docente,
        nota_dias_base="Días base (tabla mensual): suma institucional de días programados de todos los docentes (según cargo + carga horaria)."
    )

# ----------------- RESUMEN CURSO -----------------
@app.route("/api/resumen_curso")
def api_resumen_curso():
    curso = (request.args.get("curso") or "").strip()
    if not curso:
        return jsonify({"error": "curso requerido"}), 400

    q = {"curso": {"$regex": f"^{curso}$", "$options": "i"}}
    alumnos = list(COL_ALUMNOS.find({**filtro_activos(), **q}))


    total = len(alumnos)
    edades = {}
    nac = {}
    recursantes = 0
    sobreedad = 0

    for a in alumnos:
        edad = None
        if a.get("fecha_nacimiento"):
            edad = calcular_edad(a["fecha_nacimiento"])
            if edad is not None:
                edades[edad] = edades.get(edad, 0) + 1

        n = (a.get("nacionalidad") or "").strip().upper() or "SIN DATO"
        nac[n] = nac.get(n, 0) + 1

        if a.get("recursante"):
            recursantes += 1

        # sobreedad según grado (1°->6 años ... 6°->11)
        curso_txt = (a.get("curso") or "")
        grado = None
        for g in ("1", "2", "3", "4", "5", "6"):
            if curso_txt.startswith(g):
                grado = int(g)
                break
        if grado and edad and edad > (5 + grado):
            sobreedad += 1

    return jsonify({
        "curso": curso,
        "total": total,
        "edades_30jun": edades,
        "nacionalidades": nac,
        "recursantes": recursantes,
        "sobreedad": sobreedad
    })

@app.route("/resumen/calificaciones") 
def resumen_calificaciones():
    # 1) IDs activos (string)
    activos_ids = [str(a["_id"]) for a in COL_ALUMNOS.find(filtro_activos(), {"_id": 1})]

    # 2) Traer SOLO calificaciones de alumnos activos
    registros = list(COL_CALIFICACIONES.find({"alumno_id": {"$in": activos_ids}}))

    por_curso = {}
    por_asig = {}

    for c in registros:
        curso = (c.get("curso") or "").strip()
        asignatura = (c.get("asignatura") or "").strip()
        try:
            trimestre = int(c.get("trimestre") or 0)
        except Exception:
            trimestre = 0

        escala = (c.get("escala") or "").strip().lower()
        valor = (str(c.get("valor") or "")).strip()

        if not (curso and asignatura and trimestre):
            continue

        key = (curso, asignatura, trimestre)
        d_curso = por_curso.setdefault(key, {"total": 0, "desaprobados": 0})
        d_asig = por_asig.setdefault(asignatura, {"total": 0, "desaprobados": 0})

        d_curso["total"] += 1
        d_asig["total"] += 1

        desap = False 
        if escala == "conceptual":
            desap = (valor in ("R", "D"))
        elif escala == "numerica":
            try:
                n = float(valor.replace(",", "."))
                desap = (n < 6.0)
            except Exception:
                desap = False

        if desap:
            d_curso["desaprobados"] += 1
            d_asig["desaprobados"] += 1

    # Transformar a listas ordenadas + porcentaje
    resumen_curso = []
    for (curso, asignatura, trimestre), vals in sorted(por_curso.items()):
        total = vals["total"]
        desap = vals["desaprobados"]
        pct = round(desap * 100 / total, 1) if total else 0.0
        resumen_curso.append(
            {
                "curso": curso,
                "asignatura": asignatura,
                "trimestre": trimestre,
                "total": total,
                "desaprobados": desap,
                "porcentaje": pct,
            }
        )

    resumen_asig = []
    for asignatura, vals in sorted(por_asig.items()):
        total = vals["total"]
        desap = vals["desaprobados"]
        pct = round(desap * 100 / total, 1) if total else 0.0
        resumen_asig.append(
            {
                "asignatura": asignatura,
                "total": total,
                "desaprobados": desap,
                "porcentaje": pct,
            }
        )

    return render_template(
        "resumen_calificaciones.html",
        resumen_curso=resumen_curso,
        resumen_asig=resumen_asig,
    )

@app.post("/movimientos/<id>/borrar")
def borrar_movimiento(id):
    anio = (request.args.get("anio") or "").strip()
    try:
        oid = ObjectId(id)
    except Exception:
        abort(404)

    COL_MOVIMIENTOS.delete_one({"_id": oid})
    # volvemos al resumen del mismo año
    if anio:
        return redirect(url_for("resumen_movimientos", anio=anio))
    return redirect(url_for("resumen_movimientos"))


@app.get("/resumen/movimientos/exportar.xlsx")
def exportar_movimientos_excel():
    anio_param = (request.args.get("anio") or "").strip()
    try:
        anio = int(anio_param) if anio_param else date.today().year
    except ValueError:
        anio = date.today().year

    d1, d2 = _anio_range(anio)
    movs = list(COL_MOVIMIENTOS.find({
        "fecha": {"$gte": d1, "$lt": d2}
    }).sort([("fecha", -1)]))

    wb = Workbook()
    ws = wb.active
    ws.title = f"Movimientos {anio}"

    headers = ["Fecha", "Tipo", "Apellido", "Nombre", "DNI", "Curso", "Curso Origen", "Curso Destino", "Motivo", "Escuela Origen", "Escuela Destino"]
    ws.append(headers)

    def fmt_fecha(x):
        if isinstance(x, datetime):
            return x.strftime("%d/%m/%Y %H:%M")
        return str(x or "")

    for m in movs:
        ws.append([
            fmt_fecha(m.get("fecha")),
            m.get("tipo",""),
            m.get("apellido",""),
            m.get("nombre",""),
            m.get("dni",""),
            m.get("curso",""),
            m.get("curso_origen",""),
            m.get("curso_destino",""),
            m.get("motivo") or m.get("motivo_salida") or "",
            m.get("escuela_origen",""),
            m.get("escuela_destino",""),
        ])

    bio = io.BytesIO()
    wb.save(bio) 
    bio.seek(0)

    return send_file(
        bio,
        as_attachment=True,
        download_name=f"movimientos_{anio}.xlsx",
        mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    )
@app.route("/planillas/promocion")
def planilla_promocion():
    # 1. Obtenemos los parámetros de la URL
    curso_nro = request.args.get("curso", "3")    
    seccion_letra = request.args.get("seccion", "A") 
    turno = request.args.get("turno", "T.T.")
    anio_lectivo_str = request.args.get("anio", "2025")
    anio_lectivo = int(anio_lectivo_str)
    
    # CONSTRUCCIÓN DEL NOMBRE TAL CUAL ESTÁ EN ATLAS (Ej: "3°A")
    curso_completo = f"{curso_nro}°{seccion_letra}"
    
    # 2. BUSQUEDA: Filtramos por el campo curso completo y año lectivo
    query = {
        "curso": curso_completo, 
        "anio_lectivo": anio_lectivo 
    }
    
    # Traemos los alumnos ordenados por apellido
    alumnos_raw = list(app.mongo.alumnos.find(query).sort("apellido", 1))
    
    # --- PRUEBA DE CONTROL EN TERMINAL ---
    print(f"DEBUG: Buscando: {curso_completo}, Año: {anio_lectivo}")
    print(f"DEBUG: Alumnos encontrados: {len(alumnos_raw)}")
    
    alumnos_procesados = []
    fecha_hoy = date.today()
    fecha_corte = date(anio_lectivo, 6, 30)

    # 3. Calculamos edades
    for a in alumnos_raw:
        # IMPORTANTE: Verifica si en Atlas es 'fecha_nacimiento' o 'fecha_nac'
        fnac_str = a.get('fecha_nacimiento') or a.get('fecha_nac')
        edad_final = ""
        
        if fnac_str:
            try:
                fnac = datetime.strptime(fnac_str[:10], "%Y-%m-%d").date()
                
                # Usamos curso_nro para la lógica de 6to
                if curso_nro == "6":
                    edad_final = fecha_hoy.year - fnac.year - ((fecha_hoy.month, fecha_hoy.day) < (fnac.month, fnac.day))
                else:
                    edad_final = fecha_corte.year - fnac.year - ((fecha_corte.month, fecha_corte.day) < (fnac.month, fnac.day))
            except Exception:
                edad_final = ""
        
        a['edad_calculada'] = edad_final 
        alumnos_procesados.append(a)

    # 4. Variable resumen
    total_inscriptos = len(alumnos_procesados)
    resumen = {
        "total": total_inscriptos,
        "promueven": total_inscriptos, 
        "porcentaje_promocion": 100 if total_inscriptos > 0 else 0
    }

    # 5. Enviamos todo al template (Usando las variables correctas)
    return render_template("planilla_de_promocion.html", 
                           alumnos=alumnos_procesados, 
                           curso=curso_nro, # <--- Corregido
                           seccion=seccion_letra, # <--- Corregido
                           turno=turno,
                           anio=anio_lectivo,
                           resumen=resumen)

@app.route("/legajos")
def legajos_cursos():
    cursos = sorted(
        [c for c in COL_ALUMNOS.distinct("curso", filtro_activos()) if c], 
        key=lambda x: str(x)
    )
    return render_template("legajos_cursos.html", cursos=cursos)

@app.route("/legajos/<curso>")
def legajos_curso(curso):
    q = {"curso": {"$regex": f"^{curso}$", "$options": "i"}}
    alumnos = list(COL_ALUMNOS.find({**filtro_activos(), **q}).sort([("apellido", 1), ("nombre", 1)]))


    # legajo viene como subdocumento: legajo.dni_menor = True/False, etc.
    return render_template(
        "legajos_curso.html",
        curso=curso,
        alumnos=alumnos,
        campos=LEG_CAMPOS,
    )
@app.route("/legajos/<id>/actualizar", methods=["POST"])
def legajo_actualizar(id):
    try:
        oid = ObjectId(id)
    except:
        abort(404)

    sets = {}
    for code, _label in LEG_CAMPOS:
        valor = bool(request.form.get(code))
        sets[f"legajo.{code}"] = valor

    # Buscamos al alumno para saber a qué curso volver
    alumno = COL_ALUMNOS.find_one({"_id": oid})
    if not alumno:
        abort(404)

    COL_ALUMNOS.update_one({"_id": oid}, {"$set": sets})

    curso = (alumno.get("curso") or "").strip()

    # Volvemos a la pantalla del curso con un flag ok=1
    return redirect(url_for("legajos_curso", curso=curso, ok="1"))

@app.route("/autorizados")
def autorizados_cursos():
    cursos = sorted(
        [c for c in COL_ALUMNOS.distinct("curso", filtro_activos()) if c],
        key=lambda x: str(x)
    )
    return render_template("autorizados_cursos.html", cursos=cursos)

@app.route("/autorizados/<curso>")
def autorizados_curso(curso):
    q = {"curso": {"$regex": f"^{curso}$", "$options": "i"}}
    alumnos = list(COL_ALUMNOS.find({**filtro_activos(), **q}).sort([("apellido", 1), ("nombre", 1)]))

    return render_template("autorizados_curso.html", curso=curso, alumnos=alumnos)

@app.route("/autorizados/alumno/<id>", methods=["GET", "POST"])
def autorizados_alumno(id):
    try:
        oid = ObjectId(id)
    except:
        abort(404)

    a = COL_ALUMNOS.find_one({"_id": oid})
    if not a:
        abort(404)

    if request.method == "POST":
        nombres = request.form.getlist("aut_nombre[]")
        dnis = request.form.getlist("aut_dni[]")
        fns = request.form.getlist("aut_fnac[]")
        parents = request.form.getlist("aut_parentesco[]")
        doms = request.form.getlist("aut_dom[]")
        tels = request.form.getlist("aut_tel[]")

        autorizados = []
        today = date.today()

        for i in range(len(nombres)):
            nombre = (nombres[i] or "").strip()
            if not nombre:
                continue

            dni = (dnis[i] or "").strip()
            fn = (fns[i] or "").strip()
            edad = None
            if fn:
                try:
                    y, m, d = map(int, fn.split("-"))
                    nac = date(y, m, d)
                    edad = today.year - nac.year - ((today.month, today.day) < (nac.month, nac.day))
                except Exception:
                    edad = None

            autorizados.append({
                "nombre": nombre,
                "dni": dni,
                "fecha_nac": fn,
                "edad": edad,
                "parentesco": (parents[i] or "").strip(),
                "domicilio": (doms[i] or "").strip(),
                "telefono": (tels[i] or "").strip(),
            })

        COL_ALUMNOS.update_one({"_id": oid}, {"$set": {"autorizados": autorizados}})
        return redirect(url_for("autorizados_curso", curso=a.get("curso","")))

    # GET
    autorizados = a.get("autorizados") or []
    return render_template("autorizados_alumno.html", alumno=a, autorizados=autorizados)


@app.route("/certificados", methods=["GET", "POST"])
def certificados_pendientes():
    # Alta de nuevo certificado (desde el modal)
    if request.method == "POST":
        apellido = (request.form.get("apellido") or "").strip().upper()
        nombre = (request.form.get("nombre") or "").strip().upper()
        dni = (request.form.get("dni") or "").strip()
        anio_promocion_raw = (request.form.get("anio_promocion") or "").strip()
        observaciones = (request.form.get("observaciones") or "").strip()

        try:
            anio_promocion = int(anio_promocion_raw)
        except ValueError:
            anio_promocion = None   # ✔️ seguimos igual

        doc = {
            "apellido": apellido,
            "nombre": nombre,
            "dni": dni,
            "anio_promocion": anio_promocion,
            "observaciones": observaciones,
            "fecha_carga": datetime.utcnow(),
        }

        COL_CERTIFICADOS.insert_one(doc)

        # ✔️ UN SOLO return, siempre
        return redirect(url_for("certificados_pendientes"))

    # ---------------- GET ----------------
    q = (request.args.get("q") or "").strip()
    filtro = {}
    if q:
        regex = {"$regex": q, "$options": "i"}
        filtro = {"$or": [
            {"apellido": regex},
            {"dni": regex},
        ]}

    certificados = list(
        COL_CERTIFICADOS
        .find(filtro)
        .sort([("anio_promocion", -1), ("apellido", 1), ("nombre", 1)]) 
    )

    return render_template(
        "certificados_list.html",
        certificados=certificados,
        q=q,
    )

@app.route("/certificados/<id>/eliminar", methods=["POST"])
def eliminar_certificado(id):
    try:
        COL_CERTIFICADOS.delete_one({"_id": ObjectId(id)})
    except Exception:
        pass
    return redirect(url_for("certificados_pendientes")) 

@app.route("/mapa/recorridos", methods=["GET"])
def mapa_recorridos():
    """
    Pantalla para gestionar recorridos domiciliarios: 
    - filtros por curso / turno / texto
    - accesos rápidos a matrícula, legajo y autorizados
    - selección de alumnos para armar lista de visitas
    """
    q = (request.args.get("q") or "").strip()
    curso_sel = (request.args.get("curso") or "").strip()
    turno_sel = (request.args.get("turno") or "").strip()

    # Lista de cursos disponibles
    cursos = sorted(
        [c for c in COL_ALUMNOS.distinct("curso", filtro_activos()) if c],
        key=lambda x: str(x)
    )
    turnos = ["Mañana", "Tarde"]

    filtro = {}

    # Búsqueda de texto libre
    if q:
        regex = {"$regex": q, "$options": "i"}
        filtro["$or"] = [
            {"apellido": regex},
            {"nombre": regex},
            {"dni": regex},
            {"curso": regex}, 
            {"domicilio": regex},
            {"localidad": regex},
        ]

    # Filtro por curso exacto (si se eligió uno)
    if curso_sel:
        filtro["curso"] = {"$regex": f"^{curso_sel}$", "$options": "i"}
    # Si NO hay curso elegido, permitimos filtrar por turno (A/B)
    # Filtro por curso / turno
    if curso_sel:
       filtro["curso"] = {"$regex": f"^{curso_sel}$", "$options": "i"}
    elif turno_sel:
      if turno_sel.lower() == "mañana":
        filtro["curso"] = {"$regex": r"A\s*$", "$options": "i"}
      elif turno_sel.lower() == "tarde":
        filtro["curso"] = {"$regex": r"B\s*$", "$options": "i"}


    alumnos_cur = COL_ALUMNOS.find ({**filtro_activos(), **filtro}) 
    alumnos = [to_json(a) for a in alumnos_cur]

    # Ordenar como en matrícula: turno, grado, sección, apellido, nombre
    alumnos.sort(key=_orden_alumno)

    return render_template(
        "mapa_recorridos.html",
        alumnos=alumnos, 
        cursos=cursos,
        turnos=turnos,
        curso_sel=curso_sel,
        turno_sel=turno_sel,
        q=q,
        es_eoe=True
    )


@app.route("/mapa/recorridos/visitas", methods=["POST"])
def mapa_recorridos_visitas():
    """
    Genera el ACTA DE VISITA DOMICILIARIA en HTML
    para los alumnos seleccionados.
    Desde esa página se imprime o se guarda como PDF
    con el botón Imprimir.
    """
    ids = request.form.getlist("alumno_id")
    oids = []
    for _id in ids:
        try:
            oids.append(ObjectId(_id))
        except Exception:
            continue

    if not oids:
        alumnos = []
    else:
        alumnos_cur = COL_ALUMNOS.find({**filtro_activos(), "_id": {"$in": oids}}) 
        alumnos = [to_json(a) for a in alumnos_cur]
        alumnos.sort(key=_orden_alumno)

    hoy = date.today().strftime("%d/%m/%Y")

    return render_template(
        "mapa_visitas.html",
        alumnos=alumnos,
        fecha=hoy,
    )


# ----------------- ESTADOS ADMINISTRATIVOS -----------------
def calc_fecha_limite_salida(fecha_salida_str, zona):
    f = _parse_date(fecha_salida_str)
    if not f:
        return None
    z = (zona or "").strip().lower()
    if z == "distrito":
        delta = 10
    elif z == "caba":
        delta = 30
    else:
        delta = 15
    return (f - timedelta(days=delta)).strftime("%Y-%m-%d")

@app.route("/estados_admin")
def estados_admin():
    docentes = [to_json(d) for d in COL_DOCENTES.find().sort([("apellido",1),("nombre",1)])]
    tipos = [
        "salidas_educativas","planificaciones","secuencias_didacticas","proyectos",
        "reuniones_de_padres","clases_abiertas","incompatibilidad_horaria","legajo_docente",
        "cuaderno_de_actuacion","legajos_de_alumnos","boletines","registro",
        "llegadas_tarde_inasistencias","reeb","carteleras","observaciones"
    ]
    return render_template("estados_admin.html", docentes=docentes, tipos=tipos)

@app.route("/api/estados_admin", methods=["GET","POST"])
def api_estados_admin():
    if request.method == "POST":
        data = request.get_json(silent=True) or {}
        docente_id = (data.get("docente_id") or "").strip()
        tipo = (data.get("tipo") or "").strip()
        descripcion = (data.get("descripcion") or "").strip()
        fecha_notificacion = (data.get("fecha_notificacion") or "").strip()
        fecha_limite = (data.get("fecha_limite") or "").strip()
        cumplido = bool(data.get("cumplido", False))
        fecha_cumplido = (data.get("fecha_cumplido") or "").strip()
        adjunto_url = (data.get("adjunto_url") or "").strip()
        observaciones = (data.get("observaciones") or "").strip()
        fecha_salida = (data.get("fecha_salida") or "").strip()
        lugar = (data.get("lugar") or "").strip()
        zona = (data.get("zona") or "").strip()
        if tipo == "salidas_educativas" and fecha_salida and not fecha_limite:
            fecha_limite = calc_fecha_limite_salida(fecha_salida, zona)
        eid = COL_ESTADOS_ADMIN.insert_one({
            "docente_id": docente_id,
            "tipo": tipo,
            "descripcion": descripcion,
            "fecha_notificacion": fecha_notificacion,
            "fecha_limite": fecha_limite,
            "cumplido": cumplido,
            "fecha_cumplido": fecha_cumplido,
            "adjunto_url": adjunto_url,
            "observaciones": observaciones,
            "fecha_salida": fecha_salida,
            "lugar": lugar,
            "zona": zona,
            "created_at": datetime.utcnow()
        }).inserted_id
        return jsonify({"status":"ok","id":str(eid)}), 201

    # GET (con filtros)
    docente_id = request.args.get("docente_id")
    tipo = request.args.get("tipo")
    estado = (request.args.get("estado") or "").lower()
    desde = request.args.get("desde")
    hasta = request.args.get("hasta")
    q = {}
    if docente_id and docente_id != "TODOS": q["docente_id"] = docente_id
    if tipo and tipo != "TODOS": q["tipo"] = tipo
    if estado == "pendiente": q["cumplido"] = False
    elif estado == "cumplido": q["cumplido"] = True
    if desde and hasta:
        q["$or"] = [
            {"fecha_limite": {"$gte": desde, "$lte": hasta}},
            {"fecha_notificacion": {"$gte": desde, "$lte": hasta}}
        ]
    out = []
    for e in COL_ESTADOS_ADMIN.find(q).sort([("fecha_limite",1),("fecha_notificacion",1)]):
        ej = to_json(e)
        nom_doc = "—"
        if ej.get("docente_id"):
            try:
                d = COL_DOCENTES.find_one({"_id": _maybe_oid(ej["docente_id"])})
                if d: nom_doc = f"{d.get('apellido','')}, {d.get('nombre','')}".strip(", ")
            except:
                pass
        ej["docente_nombre"] = nom_doc
        ej["dias_restantes"] = dias_restantes(ej.get("fecha_limite"))
        out.append(ej)
    return jsonify(out)

@app.route("/api/estados_admin/<id>", methods=["PUT","DELETE"])
def api_estados_admin_id(id):
    if request.method == "DELETE":
        COL_ESTADOS_ADMIN.delete_one({"_id": ObjectId(id)})
        return jsonify({"status":"ok"})
    data = request.get_json(silent=True) or {}
    if data.get("tipo") == "salidas_educativas":
        if (data.get("fecha_salida") and not data.get("fecha_limite")):
            data["fecha_limite"] = calc_fecha_limite_salida(data["fecha_salida"], data.get("zona"))
    COL_ESTADOS_ADMIN.update_one({"_id": ObjectId(id)}, {"$set": data})
    e = COL_ESTADOS_ADMIN.find_one({"_id": ObjectId(id)})
    return jsonify(to_json(e))

@app.route("/api/estados_resumen")
def api_estados_resumen():
    docente_id = request.args.get("docente_id")
    tipo = request.args.get("tipo")
    q = {}
    if docente_id and docente_id != "TODOS": q["docente_id"] = docente_id
    if tipo and tipo != "TODOS": q["tipo"] = tipo
    total = COL_ESTADOS_ADMIN.count_documents(q)
    pipeline_tipo = [{"$match": q}, {"$group": {"_id": "$tipo", "count": {"$sum": 1}}}]
    agg_tipo = {a["_id"]: a["count"] for a in COL_ESTADOS_ADMIN.aggregate(pipeline_tipo) if a["_id"]}
    pendientes = COL_ESTADOS_ADMIN.count_documents({**q, "cumplido": False})
    cumplidos = COL_ESTADOS_ADMIN.count_documents({**q, "cumplido": True})
    proximos = []
    for e in COL_ESTADOS_ADMIN.find({**q, "cumplido": False}):
        dr = dias_restantes(e.get("fecha_limite"))
        if dr is not None and dr <= 5:
            ej = to_json(e); ej["dias_restantes"] = dr; proximos.append(ej)
    en_10 = []
    for e in COL_ESTADOS_ADMIN.find({**q, "cumplido": False}):
        dr = dias_restantes(e.get("fecha_limite"))
        if dr is not None and 0 <= dr <= 10: en_10.append(to_json(e))
    return jsonify({
        "total": total, "por_tipo": agg_tipo,
        "pendientes": pendientes, "cumplidos": cumplidos,
        "criticos_5dias": proximos, "en_10dias": en_10,
        "hoy": today().strftime("%Y-%m-%d")
    })
#-----------------------AUXILIARES  -----------------

@app.route("/auxiliares")
def listar_auxiliares():
    auxs = [to_json(a) for a in COL_AUX.find().sort([("apellido", 1), ("nombre", 1)])]
    return render_template("auxiliares.html", auxiliares=auxs)


@app.route("/auxiliares/nuevo", methods=["POST"])
def nuevo_auxiliar():
    data = request.form.to_dict()
    COL_AUX.insert_one(data)
    return redirect(url_for("listar_auxiliares"))


@app.route("/auxiliares/<id>/editar", methods=["POST"])
def editar_auxiliar(id):
    updates = request.form.to_dict()
    COL_AUX.update_one({"_id": ObjectId(id)}, {"$set": updates})
    return redirect(url_for("listar_auxiliares"))


@app.route("/auxiliares/<id>/eliminar", methods=["POST"])
def eliminar_auxiliar(id):
    COL_AUX.delete_one({"_id": ObjectId(id)})
    return redirect(url_for("listar_auxiliares"))


# --------- CARGA INASISTENCIAS AUX (vista) ---------

@app.route("/aux_inasistencias")
def aux_ver_inasistencias():
    if not mongo_ping_ok():
        return render_template("db_down.html"), 503
    return render_template("aux_inasistencias.html")


@app.get("/api/auxiliares")
def api_auxiliares():
    out = []
    for a in COL_AUX.find().sort([("apellido", 1), ("nombre", 1)]):
        out.append({
            "_id": str(a["_id"]),
            "nombre": a.get("nombre", ""),
            "apellido": a.get("apellido", ""),
            "cargo": a.get("cargo", ""),
        })
    return jsonify(out)


@app.post("/api/aux_inasistencias")
def api_aux_inasistencias():
    if not mongo_ping_ok():
        return jsonify(ok=False, error="db_down"), 503

    data = request.get_json(silent=True) or {}

    auxiliar_id_raw = data.get("auxiliar_id") or data.get("auxiliar")
    if not auxiliar_id_raw:
        return jsonify(ok=False, error="Auxiliar requerido."), 400

    auxiliar_id = _maybe_oid(auxiliar_id_raw)

    desde = _parse_date(data.get("desde") or data.get("fecha"))
    hasta = _parse_date(data.get("hasta") or data.get("fecha"))

    if not desde:
        return jsonify(ok=False, error="Fecha 'desde' requerida."), 400
    if not hasta:
        hasta = desde
    if hasta < desde:
        desde, hasta = hasta, desde

    # No permitir fechas futuras
    if desde > date.today() or hasta > date.today():
        return jsonify(ok=False, error="Fecha inválida: no se pueden cargar inasistencias futuras."), 400

    causa = (data.get("causa") or "").strip()
    if not causa:
        return jsonify(ok=False, error="Causa requerida."), 400

    observ = (data.get("observaciones") or "").strip()

    suplente_info = {
        "nombre": (data.get("sup_nombre") or data.get("suplente_nombre") or "").strip(),
        "dni": (data.get("sup_dni") or "").strip(),
        "curso": (data.get("sup_curso") or "").strip(),
        "asignatura": (data.get("sup_asignatura") or "").strip(),
    }
    suplente_info = {k: v for k, v in suplente_info.items() if v} 

    # Reglas “particulares” (igual que docentes): 1 día por mes, máx 6/año
    bucket = _causa_bucket(_norm(causa))
    cont_anual, meses_particulares =_contar_por_bucket_aux_anio (auxiliar_id, referencia_fecha=desde)

    if bucket == "particulares":
        if desde != hasta:
            return jsonify(ok=False, error="Causas particulares: debe ser UN (1) solo día (1 por mes)."), 400

        key_mes = f"{desde.year}-{desde.month:02d}"
        if meses_particulares.get(key_mes, 0) >= 1:
            return jsonify(ok=False, error="Ya hay una inasistencia por 'causas particulares' en este mes."), 400

        if cont_anual.get("particulares", 0) >= 6:
            return jsonify(ok=False, error="Se alcanzó el tope anual de 'causas particulares' (6)."), 400

    # Evitar duplicado por día (idempotente)
    dias_a_insertar = []
    dcur = desde
    while dcur <= hasta:
        fecha_iso = dcur.isoformat()

        existente = COL_INASISTENCIAS_AUX.find_one({"auxiliar_id": auxiliar_id, "fecha": fecha_iso})
        if existente:
            same = (
                (existente.get("causa") or "").strip() == causa and
                (existente.get("observaciones") or "").strip() == observ and
                (existente.get("suplente_info") or {}) == suplente_info
            )
            if same:
                dcur += timedelta(days=1)
                continue

            msg = f"Ya hay una inasistencia cargada para este auxiliar el {dcur.strftime('%d/%m/%Y')}."
            return jsonify(ok=False, error=msg), 400

        dias_a_insertar.append(fecha_iso)
        dcur += timedelta(days=1)

    docs = [{
        "auxiliar_id": auxiliar_id,
        "fecha": f,
        "causa": causa,
        "observaciones": observ,
        "suplente_info": suplente_info,
    } for f in dias_a_insertar]

    if docs:
        COL_INASISTENCIAS_AUX.insert_many(docs)

    return jsonify(ok=True, inserted=len(docs), warning=None)


# --------- HISTORIAL AUX (vista + APIs) ---------

@app.get("/aux_inasistencias/historial")
def aux_historial_inasistencias():
    if not mongo_ping_ok():
        return render_template("db_down.html"), 503

    auxs = list(COL_AUX.find().sort([("apellido", 1), ("nombre", 1)]))
    auxs = [{"_id": str(a["_id"]), "apellido": a.get("apellido", ""), "nombre": a.get("nombre", "")} for a in auxs]
    return render_template("historial_inasistencias_aux.html", auxiliares=auxs)


@app.get("/api/aux_historial_lista")
def api_aux_historial_lista():
    if not mongo_ping_ok():
        return jsonify({"ok": False, "error": "db_down"}), 503

    q = _aux_historial_query_from_args(request.args)
    ins_list = list(COL_INASISTENCIAS_AUX.find(q).sort("fecha", 1))

    aux_oids = []
    for ins in ins_list:
        aid = ins.get("auxiliar_id")
        if aid:
            try:
                aux_oids.append(_maybe_oid(aid))
            except Exception:
                pass
    aux_oids = [a for a in aux_oids if a is not None]

    aux_map = {}
    if aux_oids:
        for a in COL_AUX.find({"_id": {"$in": aux_oids}}, {"apellido": 1, "nombre": 1, "cargo": 1}):
            aux_map[str(a["_id"])] = {
                "nombre": a.get("nombre", ""),
                "apellido": a.get("apellido", ""),
                "cargo": a.get("cargo", ""),
            }

    rows = []
    for ins in ins_list:
        aid_raw = ins.get("auxiliar_id")
        aid_str = str(aid_raw) if aid_raw is not None else ""
        a = aux_map.get(aid_str, {})
        aux_nombre = f"{a.get('apellido','')}, {a.get('nombre','')}".strip(", ") if a else ""

        rows.append({
            "_id": str(ins.get("_id")),
            "fecha": ins.get("fecha", ""),
            "causa": ins.get("causa", ""),
            "observaciones": ins.get("observaciones", ""),
            "suplente_info": ins.get("suplente_info") or {},
            "auxiliar_id": aid_str,
            "auxiliar_nombre": aux_nombre,
        })

    return jsonify({"ok": True, "items": rows})


@app.get("/api/aux_historial_resumen")
def api_aux_historial_resumen():
    if not mongo_ping_ok():
        return jsonify({"ok": False, "error": "db_down"}), 503

    q = _aux_historial_query_from_args(request.args)

    por = {
        "enfermedad_personal": 0,
        "enfermedad_familiar": 0,
        "enfermedad_cronica": 0,
        "particulares": 0,
        "citacion_otro_establecimiento": 0,
        "injustificadas": 0,
        "pre_examen": 0,
        "duelo": 0,
        "examen": 0,
        "paro": 0,
        "art": 0,
        "licencia_extraordinaria": 0,
        "otras": 0,
    }

    total = 0
    for ins in COL_INASISTENCIAS_AUX.find(q, {"causa": 1}):
        total += 1
        b = _causa_bucket(_norm(ins.get("causa", "")))
        if b not in por:
            b = "otras"
        por[b] += 1

    return jsonify({"ok": True, "total": total, "por_causa": por})


# --------- EDITAR / ELIMINAR AUX ---------

@app.route("/aux_inasistencias/<id>/editar", methods=["GET", "POST"])
def aux_inasistencia_editar(id):
    if not mongo_ping_ok():
        return render_template("db_down.html"), 503

    try:
        oid = ObjectId(id)
    except Exception:
        abort(404)

    ins = COL_INASISTENCIAS_AUX.find_one({"_id": oid})
    if not ins:
        abort(404)

    if request.method == "POST":
        fecha = (request.form.get("fecha") or "").strip()
        causa = (request.form.get("causa") or "").strip()
        observaciones = (request.form.get("observaciones") or "").strip()

        if not fecha or not causa:
            flash("Fecha y causa son obligatorias.", "danger")
            return redirect(url_for("aux_inasistencia_editar", id=id))

        f = _parse_date(fecha)
        if not f:
            flash("Fecha inválida.", "danger")
            return redirect(url_for("aux_inasistencia_editar", id=id))

        if f > date.today():
            flash("Fecha inválida: no se permiten inasistencias futuras.", "danger")
            return redirect(url_for("aux_inasistencia_editar", id=id))

        sup = {
            "nombre": (request.form.get("suplente_nombre") or "").strip(),
            "dni": (request.form.get("suplente_dni") or "").strip(),
            "curso": (request.form.get("suplente_curso") or "").strip(),
        }
        sup = {k: v for k, v in sup.items() if v}

        COL_INASISTENCIAS_AUX.update_one(
            {"_id": oid},
            {"$set": {
                "fecha": fecha,
                "causa": causa,
                "observaciones": observaciones,
                "suplente_info": sup,
            }}
        )
        flash("Inasistencia actualizada.", "success")
        return redirect(url_for("aux_historial_inasistencias"))


    ins["_id"] = str(ins["_id"])
    return render_template("inasistencias_aux_editar.html", inasistencia=ins)


@app.delete("/api/aux_inasistencias/<id>")
def api_aux_inasistencias_delete(id):
    if not mongo_ping_ok():
        return jsonify({"ok": False, "error": "db_down"}), 503

    try:
        oid = ObjectId(id) 
    except Exception:
        return jsonify({"ok": False, "error": "id inválido"}), 400

    r = COL_INASISTENCIAS_AUX.delete_one({"_id": oid})
    if r.deleted_count != 1:
        return jsonify({"ok": False, "error": "No se encontró la inasistencia"}), 404

    return jsonify({"ok": True})


# --------- CALENDARIO ANUAL AUX (tipo SET4) ---------

@app.route("/auxiliares/<id>/inasistencias_anuales")
def auxiliar_inasistencias_anuales(id):
    try:
        oid = ObjectId(id)
    except Exception:
        abort(404)

    anio_param = (request.args.get("anio") or "").strip()
    try:
        anio = int(anio_param) if anio_param else date.today().year
    except ValueError:
        anio = date.today().year

    aux = COL_AUX.find_one({"_id": oid})
    if not aux:
        abort(404)

    desde_iso = date(anio, 1, 1).isoformat()
    hasta_iso = date(anio, 12, 31).isoformat()

    totales = {
        "enfermedad_personal": 0,
        "enfermedad_familiar": 0,
        "enfermedad_cronica": 0,
        "particulares": 0,
        "citacion_otro_establecimiento": 0,
        "injustificadas": 0,
        "pre_examen": 0,
        "duelo": 0,
        "examen": 0,
        "paro": 0,
        "art": 0,
        "licencia_extraordinaria": 0,
        "otras": 0, 
        "suma": 0
    }

    faltas_por_fecha = {}
    q = {"auxiliar_id": oid, "fecha": {"$gte": desde_iso, "$lte": hasta_iso}}

    for ins in COL_INASISTENCIAS_AUX.find(q):
        f = _parse_date(ins.get("fecha"))
        if not f:
            continue
        causa = (ins.get("causa") or "").strip()

        b = _causa_bucket(_norm(causa))
        if b in totales:
            totales[b] += 1
        else:
            totales["otras"] += 1

        totales["suma"] += 1
        faltas_por_fecha[(f.month, f.day)] = _color_for_causa(causa)

    meses_data = []
    for mes in range(1, 13):
        dias_habiles = get_dias_habiles(anio, mes)

        filas = []
        fila_actual = [None] * 5
        last_weekday = None

        for f in dias_habiles:
            wd = f.weekday()

            if last_weekday is not None and wd == 0:
                if any(c is not None for c in fila_actual):
                    filas.append(fila_actual)
                fila_actual = [None] * 5

            fila_actual[wd] = {"dia": f.day, "color": faltas_por_fecha.get((mes, f.day))}
            last_weekday = wd

        if any(c is not None for c in fila_actual):
            filas.append(fila_actual)

        meses_data.append({
            "num": mes,
            "nombre": MESES_MAYUS.get(mes, str(mes)),
            "filas": filas,
        })

    return render_template(
        "auxiliar_inasistencias_calendario.html",  # ✅ este nombre tiene que existir
        auxiliar=aux,
        anio=anio,
        meses=meses_data,
        totales=totales,
        periodo={"desde": desde_iso, "hasta": hasta_iso},
        fecha_impresion=date.today(),
    )

# ----------------- ANEXOS (Punto 4) -----------------
# ----------------- ANEXOS (Modelos oficiales exactos) -----------------

@app.route("/anexos")
def anexos_index():
    # Cursos desde alumnos
    cursos = COL_ALUMNOS.distinct("curso") 
    cursos = sorted(
    [c for c in COL_ALUMNOS.distinct("curso", filtro_activos()) if c],
    key=lambda x: str(x)
    )

    docentes = [to_json(d) for d in COL_DOCENTES.find().sort([("apellido",1),("nombre",1)])]
    return render_template("anexos_index.html", cursos=cursos, docentes=docentes)
@app.route("/anexos/render", methods=["POST"])
def anexos_render():
    form = request.form.to_dict()
    tipo = (form.get("tipo") or "").strip().lower()
    curso = (form.get("curso") or "").strip()
    docente_id = (form.get("docente_id") or "").strip()

    # Docente
    docente = None
    if docente_id:
        d = COL_DOCENTES.find_one({"_id": _maybe_oid(docente_id)})
        if d:
            docente = to_json(d)

    # ✅ ALUMNOS SIEMPRE DEFINIDA (evita UnboundLocalError)
    alumnos = []

    # Alumnos del curso (solo activos)
    if curso:
        cur_regex = f"^{curso}$"
        cur = COL_ALUMNOS.find(
            {**filtro_activos(), "curso": {"$regex": cur_regex, "$options": "i"}}
        ).sort([("apellido", 1), ("nombre", 1)])

        for a in cur:
            aj = to_json(a)
            if aj.get("fecha_nacimiento"):
                aj["edad_30jun"] = calcular_edad(aj["fecha_nacimiento"])
            alumnos.append(aj)

    # Datos de salida
    salida = {
        "fecha": form.get("fecha_salida") or "",
        "hora": form.get("hora_salida") or "",
        "lugar": form.get("lugar") or "",
        "zona": form.get("zona") or "",
    }

    transporte = {
        "empresa": form.get("micro_empresa") or "",
        "patente": form.get("micro_patente") or "",
        "chofer_nombre": form.get("chofer_nombre") or "",
        "chofer_dni": form.get("chofer_dni") or "",
        "chofer_licencia": form.get("chofer_licencia") or "",
        "seguro": form.get("seguro") or "",
    }

    escuela = {
        "nombre": form.get("escuela_nombre") or 'EP N° 91 "PROVINCIAS ARGENTINAS"',
        "domicilio": form.get("escuela_domicilio") or "Tomás Edison 2164, Isidro Casanova",
        "telefono": form.get("escuela_telefono") or "",
        "distrito": form.get("escuela_distrito") or "La Matanza",
        "region": form.get("escuela_region") or "III",
    }

    ctx = {
        "curso": curso,
        "docente": docente,
        "alumnos": alumnos,
        "salida": salida,
        "transporte": transporte,
        "escuela": escuela,
        "hoy": today().strftime("%d/%m/%Y"),
    }

    template_map_exact = {
        "anexo_3":  "anexo_3_exact.html",
        "anexo_4":  "anexo_4_exact.html",
        "anexo_v":  "anexo_v_exact.html",
        "anexo_vi": "anexo_vi_exact.html",
        "anexo_7":  "anexo_7_exact.html",
        "anexo_8":  "anexo_8_exact.html",
    }

    if not tipo:
        return jsonify({"ok": False, "error": "Falta elegir tipo de anexo"}), 400

    tmpl = template_map_exact.get(tipo)
    if not tmpl:
        return jsonify({"ok": False, "error": f"Tipo de anexo inválido: {tipo}"}), 400

    return render_template(tmpl, **ctx)


# ----------------- Main -----------------
if __name__ == "__main__":
    import os
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=True)

